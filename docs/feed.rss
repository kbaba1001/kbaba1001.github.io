<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:wfw="http://wellformedweb.org/CommentAPI/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:sy="http://purl.org/rss/1.0/modules/syndication/" xmlns:slash="http://purl.org/rss/1.0/modules/slash/" version="2.0">
  <channel>
    <title>kbaba1001 ブログ</title>
    <link>https://www.kbaba1001.com/</link>
    <atom:link href="https://www.kbaba1001.com/feed.rss" rel="self" type="application/rss+xml"/>
    <description>Clojure 好きなプログラマ kbaba1001 のブログ</description>
    <lastBuildDate>Sun, 17 Dec 2023 15:00:00 GMT</lastBuildDate>
    <language>ja_JP</language>
    <generator>Lume v2.0.1</generator>
    <item>
      <title>いにしえのホームページを Clojure の最先端技術で作りたい</title>
      <link>https://www.kbaba1001.com/posts/2024012501_homepage/</link>
      <guid isPermaLink="false">https://www.kbaba1001.com/posts/2024012501_homepage/</guid>
      <description/>
      <content:encoded>
        <![CDATA[<p>このブログを運用し始めて約１か月。</p>
        <p>さっそくアクセスカウンターとか掲示板とか欲しくなってきた。 Twitter
        もやめてしまったのでどうせならマイクロポストの機能もほしい。</p>
        <p>そんな感じの個人サイトを Clojure で作ろうかと思っている。</p>
        <h3>サーバーサイド開発について</h3>
        <p>サーバーサイドを今まで <a href="https://github.com/duct-framework/duct">Duct</a>
        で作ってきたのだが、別に Duct 使わなくてもいいんじゃないかなと思えてきた。 Duct
        は <code>defmethod</code> を活用して関数を疎結合にしてシステムを構築するのだが、</p>
        <ul>
        <li>別に毎回そこまで疎結合じゃなくてもいい</li>
        <li>むしろコードジャンプできなくて辛い</li>
        <li>edn ファイルでシステムを定義するのが面倒くさい</li>
        </ul>
        <p>というあたりでやめようと思った。</p>
        <p>ではどうするかというと、他の言語でよくやるのと同じようにオートリロードできれば十分だと思う。
        調べたら
        <a href="https://ring-clojure.github.io/ring/ring.middleware.reload.html">ring にはそもそもオートリロードの機能がある</a>
        ようなのでこれを使いたい。
        <a href="https://github.com/weavejester/ring-refresh">ring-refresh</a>
        というライブラリもあるし。
        <a href="https://practical.li/clojure-web-services/projects/leiningen/todo-app/reloading-the-application/">使い方</a></p>
        <p>あとは <a href="https://github.com/metosin/reitit">reitit</a>
        とかでルーティングを作れば十分だろう。 DB
        コネクションの各ファイルへの受け渡しだけなんとかする。 必要であればここだけ
        <a href="https://github.com/clojure/core.async">core.async</a> の
        <a href="https://clojuredocs.org/clojure.core.async/pipeline">pipeline</a>
        とかで疎結合にしておけばいい。</p>
        <p>参考:
        <a href="https://boxofpapers.hatenablog.com/entry/core_async">Clojure + core.async による非同期＆並列プロセスの世界</a></p>
        <h3>フロントエンド開発について</h3>
        <p>今まで <a href="https://github.com/thheller/shadow-cljs">shadow-cljs</a> +
        <a href="https://github.com/lilactown/helix">helix</a>
        構成を試してきてこれはかなり快適だったのだが、新しい試みとして
        <a href="https://github.com/squint-cljs/squint">Squint</a> を試したいと思っている。</p>
        <p>Squint は ClojureScript を js に変換するコンパイラで、最大の特徴として <strong>Java
        に依存していない!!</strong>。 つまり TypeScript のコンパイラなどと同様に package.json
        に書いておけば、それだけで cljs を js に変換できる。 shadow-cljs
        がやりたかったことをもう一歩進めた感じだ。 Squint は js
        に寄っているが、もっと標準的な ClojureScript に寄せた
        <a href="https://github.com/squint-cljs/cherry">Cherry</a> というのもある。 Squint を使えば
        React や Vite などのフロントエンド開発で使われるツールを
        そのまま使うことができる。<a href="https://github.com/squint-cljs/squint/tree/main/examples/vite-react">examples/vite-react</a></p>
        <p>これらは <a href="https://github.com/babashka/babashka">babashka</a> の作成者として有名な
        borkdude
        さんの作品で、彼は本当にこういうものを作るのが上手だしまめに作っていると思う。
        尊敬しかない。</p>
        <p>Squint
        はまだ本番環境で使うことを推奨していないようだけど、まぁ個人サイトのフロントエンドを作るくらいなら後で
        Squint の仕様が変わったとしてもあまり困らない気がする。 Clojure コミュニティの
        Slack 見ているとすでに結構出来上がっている雰囲気あるし。</p>
        <p>Squint は CljureScript の歴史を変える可能性があるプロダクトだと思っているので
        ぜひとも試してみたい。 今までの ClojureScript では面倒になる <code>Promise</code>,
        <code>async/await</code> まわりも楽にかけそうだし、 <code>jsx</code> との統合も魅力的だ。 一方で nREPL
        や Macros も使える。</p>
        <p>最高では～！</p>
        ]]>
      </content:encoded>
      <pubDate>Thu, 25 Jan 2024 00:00:00 GMT</pubDate>
    </item>
    <item>
      <title>久々に買ってみた技術書</title>
      <link>https://www.kbaba1001.com/posts/2024012201_technologies-books/</link>
      <guid isPermaLink="false">https://www.kbaba1001.com/posts/2024012201_technologies-books/</guid>
      <description/>
      <content:encoded>
        <![CDATA[<p>久しぶりに Web 系の技術書を買ってみた。</p>
        <p><img src="https://www.kbaba1001.com/img/posts/2024012201/tech-books.jpg" alt="tech-books"></p>
        <ul>
        <li>RustとWebAssemblyによるゲーム開発</li>
        <li>Web パフォーマンスチューニング ISUCON</li>
        <li>フロントエンド開発のためのセキュリティ入門</li>
        <li>フロントエンド開発のためのテスト入門</li>
        </ul>
        <p>長らく技術書を買ったり読んだりしてなかった。だいたいのことはライブラリとかの公式サイト読む方がいいし。
        最近少し大き目の本屋に行く機会があって、久しぶりに技術書を見ていたら色々と良さそうな本もあったので、
        久しぶりに自分のために買ってみることにした。</p>
        <p>『フロントエンド開発のためのテスト入門』と『フロントエンド開発のためのセキュリティ入門』の２冊は前から気になっていたので購入。
        そういえばあまりフロントのテスト書いてなかったわ。 js-dom とか一応入れるだけ入れてちゃんとした React コンポーネントのテスト書いたことないかも。という自戒も込めて。</p>
        <p>『フロントエンド開発のためのセキュリティ入門』の方は答え合わせのつもりで購入。たぶんだいたい知っているとは思うけど、この際知識を整理しておきたい。</p>
        <p>『Web パフォーマンスチューニング ISUCON』は Amazon で見つけて衝動買い。
        パフォーマンスチューニングも意外と知らないことある気がした。
        CDN とかあんま詳しくないし。</p>
        <p>『RustとWebAssemblyによるゲーム開発』は Rust と WebAssembly の知識が両方 0 なのだが、
        WebAssembly に GC がないので Rust のような GC がなくても現代的な開発ができる言語が人気ときいて
        やってみたくなったため。
        ゲーム開発をする予定はないけど、フロントではちょっと重い処理をなんとか速くしたいみたいなときに
        WebAssembly 使えたら面白いかもなぁ、という気持ち。</p>
        <p>何にせよ自分のために技術の本を買うのは結構久々で、普通に読むのが楽しみだ。
        新人教育的な目的で購入した本は結構あるし、一時期は O'Reilly online で英語の本とか読んでたけど、
        最近はそういうのもすっかりやらなくなってしまった。</p>
        ]]>
      </content:encoded>
      <pubDate>Mon, 22 Jan 2024 00:00:00 GMT</pubDate>
    </item>
    <item>
      <title>自動交渉のライブラリを作った</title>
      <link>https://www.kbaba1001.com/posts/2024012101_auto-negotiator/</link>
      <guid isPermaLink="false">https://www.kbaba1001.com/posts/2024012101_auto-negotiator/</guid>
      <description/>
      <content:encoded>
        <![CDATA[<p><a href="https://github.com/neumann-tokyo/auto_negotiator">Auto Negotiator</a>
        というライブラリを TypeScript で作った。</p>
        <p>npm package はこちら:
        <a href="https://www.npmjs.com/package/auto_negotiator">auto_negotiator</a></p>
        <h2>自動交渉の概要</h2>
        <p>自動交渉については ↓
        の記事などがわかりやすい（というかこれ以外あんまなかった）。</p>
        <p><a href="https://engineering.mercari.com/blog/entry/2017-12-07-103000/">自動交渉 AI から見る&quot;AI 同士がつながる世界&quot;</a></p>
        <p>自動交渉は交渉を行うエージェントを数体作成して、それらのエージェントの希望を考慮しつつ満場一致になる選択肢を導き出すというもの。</p>
        <p>例えば、夕食のメニューを考えるときに、</p>
        <ul>
        <li>主食
        <ul>
        <li>ご飯</li>
        <li>パン</li>
        <li>麺</li>
        </ul>
        </li>
        <li>メインディッシュ
        <ul>
        <li>ステーキ</li>
        <li>魚</li>
        <li>チキン</li>
        </ul>
        </li>
        </ul>
        <p>みたいな選択肢があって、エージェント A は
        <code>{主食: ご飯, メインディッシュ: ステーキ}</code> がよく、エージェント B は
        <code>{主食: ご飯, メインディッシュ: 魚}</code>
        がよいという意見を持っている場合に、エージェント A, B
        がある程度納得して同意（満場一致）できる献立を考えるというもの。</p>
        <h2>プログラムでの表現</h2>
        <p>自動交渉を行うには、エージェントとトピックが必要だ。
        ライブラリの本体とは別にサンプルコードも用意したので、以下はサンプルコードを元にして説明する。</p>
        <h3>トピック</h3>
        <p>まずトピックについて説明する。</p>
        <p><a href="https://github.com/neumann-tokyo/auto_negotiator/blob/main/sample/topic/dinner/agent1.ts">https://github.com/neumann-tokyo/auto_negotiator/blob/main/sample/topic/dinner/agent1.ts</a></p>
        <pre><code class="language-typescript">import { Topic } from &quot;../../../src/types&quot;;
        
        export const topic: Topic = {
        name: &quot;Dinner&quot;,
        description: &quot;What should we have dinner?&quot;,
        discount_factor: 0.1,
        reservation: 0.3,
        issues: [
        {
        name: &quot;Staple food&quot;,
        weight: 0.3,
        items: [
        {
        name: &quot;Rice&quot;,
        evaluation: 7,
        },
        {
        name: &quot;Noodles&quot;,
        evaluation: 2,
        },
        {
        name: &quot;Bread&quot;,
        evaluation: 1,
        },
        ],
        },
        {
        name: &quot;Main dish&quot;,
        weight: 0.7,
        items: [
        {
        name: &quot;Steak&quot;,
        evaluation: 1,
        },
        {
        name: &quot;Fish&quot;,
        evaluation: 1,
        },
        {
        name: &quot;Chicken&quot;,
        evaluation: 8,
        },
        ],
        },
        ],
        };
        </code></pre>
        <p>上記のように夕食の献立というトピックにたいして、どのような意見を持っているかを決める。
        まず、この agent1 は主食 (Staple food) とメインディッシュ (Main dish)
        に対して、それぞれ 0.3 と 0.7 の重み (weight) をつけている。 weight
        は全体で合計が 1.0 になるように設定する必要があり、どの issue
        に大して優先したいかを示す。 ようするに、 agent1 はメインディッシュに関して 70%
        優先したいと考えている。逆に言えば主食に関しては譲歩しやすい。</p>
        <pre><code>  name: &quot;Staple food&quot;,
        weight: 0.3,
        
        name: &quot;Main dish&quot;,
        weight: 0.7,
        </code></pre>
        <p>次に、issue の中について見てみると <code>items</code> に選択肢として Rice, Noodles, Bread
        があり、その evaluation が 7, 2, 1 となっている。 evaluation については Integer
        でどのような数値を置いても良いが、合計が 10 や 100
        になるようにするとわかりやすい。
        （内部で処理する際はこの数値に重みを付けて正規化する）</p>
        <pre><code class="language-typescript">{
        name: &quot;Staple food&quot;,
        weight: 0.3,
        items: [
        {
        name: &quot;Rice&quot;,
        evaluation: 7,
        },
        {
        name: &quot;Noodles&quot;,
        evaluation: 2,
        },
        {
        name: &quot;Bread&quot;,
        evaluation: 1,
        },
        ],
        },
        </code></pre>
        <p>evaluation
        の値が大きいほどその選択肢にしたいという意思が強くなるため、上記の場合では
        agent1 は Rice を食べたいという意思が強いことがわかる。</p>
        <h3>エージェント</h3>
        <p>エージェントは他のエージェントからの提案やトピックを元にしてどのように自分の意見を主張していくかを決定づけるものだ。</p>
        <p>ソースコードを元に説明する。</p>
        <p><a href="https://github.com/neumann-tokyo/auto_negotiator/blob/main/sample/agents/sample-agent.ts">https://github.com/neumann-tokyo/auto_negotiator/blob/main/sample/agents/sample-agent.ts</a></p>
        <pre><code class="language-typescript">import * as helper from &quot;../../src/helper&quot;;
        import * as types from &quot;../../src/types&quot;;
        
        // この関数は試行のたびに呼び出される。
        // 引数には全体の状況や自分のトピックがはいってきて、自分の意見を返すとそれが他のエージェントにも伝わる。
        export function sampleAgent({
        data: { id, attempts, attemptsCount },
        normalizedTopic,
        }: types.ActionFnParams): types.ActionFnResponse {
        // 現在の試行における他のエージェントからの提案などがはいっている
        const currentAttempt = helper.currentAttempt({ id, attempts });
        
        // 試行回数を元にして譲歩値を設定する。 1.0 - progress なので徐々に譲歩値は下がっていく。
        // つまり、他からの意見に同意しやすくなる
        const progress = helper.progress({ id, attemptsCount });
        const concessionValue = 1.0 - progress;
        
        for (const status of currentAttempt) {
        if (status.type === types.AtemptType.Offer) {
        const anotherConcessionValue = helper.choicesToConcessionValue({
        choices: status.choices,
        });
        
        // 相手からの提案のほうが自分の譲歩値より高いのであれば同意する
        if (concessionValue &lt; anotherConcessionValue) {
        return {
        id,
        choices: status.choices,
        concessionValue: anotherConcessionValue,
        type: types.AtemptType.Accept,
        };
        }
        }
        }
        
        // 同意できない場合に自分の意見を作成する
        const { choices, threshold } = helper.concessionValueToChoices({
        normalizedTopic,
        concessionValue,
        });
        return {
        id,
        choices,
        concessionValue,
        type: types.AtemptType.Offer,
        };
        }
        </code></pre>
        <p>上記はエージェントのサンプルでしかなく、もっと自由に作って良い。</p>
        <h3>自動交渉の実行</h3>
        <p>最後はエージェントとトピックを元にして自動交渉を行う。</p>
        <p><a href="https://github.com/neumann-tokyo/auto_negotiator/blob/main/sample/run.ts">https://github.com/neumann-tokyo/auto_negotiator/blob/main/sample/run.ts</a></p>
        <pre><code class="language-typescript">import { prettyPrint } from &quot;../src/helper&quot;;
        import * as negotiator from &quot;../src/index&quot;;
        import { sampleAgent } from &quot;./agents/sample-agent&quot;;
        import { topic as agent1Topic } from &quot;./topic/dinner/agent1&quot;;
        import { topic as agent2Topic } from &quot;./topic/dinner/agent2&quot;;
        import { topic as agent3Topic } from &quot;./topic/dinner/agent3&quot;;
        
        // これは任意の値を設定して良い
        const channelName = &quot;dinner&quot;;
        
        // エージェントとそのトピックを登録する
        negotiator.defineAgent({
        channelName: channelName,
        agentName: &quot;agent1&quot;,
        topic: agent1Topic,
        actionFn: sampleAgent,
        });
        negotiator.defineAgent({
        channelName: channelName,
        agentName: &quot;agent2&quot;,
        topic: agent2Topic,
        actionFn: sampleAgent,
        });
        negotiator.defineAgent({
        channelName: channelName,
        agentName: &quot;agent3&quot;,
        topic: agent3Topic,
        actionFn: sampleAgent,
        });
        
        // 自動交渉を行う。試行回数（attemptsCount）は 30 回、エージェント数 (agentsCount) は 3 体
        const result = negotiator.negotiate({
        channelName,
        attemptsCount: 30,
        agentsCount: 3,
        });
        
        // 結果の表示
        prettyPrint(result);
        </code></pre>
        <p>自動交渉の結果は次のようになる。</p>
        <p><a href="https://github.com/neumann-tokyo/auto_negotiator/blob/main/sample/result.json">https://github.com/neumann-tokyo/auto_negotiator/blob/main/sample/result.json</a></p>
        <pre><code class="language-json">{
        &quot;isAgreed&quot;: true,
        &quot;id&quot;: 7,
        &quot;attemptsCount&quot;: 8,
        &quot;conclusion&quot;: [
        {
        &quot;choices&quot;: [
        {
        &quot;issueName&quot;: &quot;Staple food&quot;,
        &quot;item&quot;: {
        &quot;name&quot;: &quot;Rice&quot;,
        &quot;evaluation&quot;: 7,
        &quot;normalizedEvaluation&quot;: 0.21000000000000002
        }
        },
        {
        &quot;issueName&quot;: &quot;Main dish&quot;,
        &quot;item&quot;: {
        &quot;name&quot;: &quot;Chicken&quot;,
        &quot;evaluation&quot;: 8,
        &quot;normalizedEvaluation&quot;: 0.5599999999999999
        }
        }
        ],
        &quot;concessionValue&quot;: 0.7666666666666666,
        &quot;type&quot;: &quot;offer&quot;,
        &quot;agentName&quot;: &quot;agent1&quot;
        },
        {
        &quot;choices&quot;: [
        {
        &quot;issueName&quot;: &quot;Staple food&quot;,
        &quot;item&quot;: {
        &quot;name&quot;: &quot;Rice&quot;,
        &quot;evaluation&quot;: 7,
        &quot;normalizedEvaluation&quot;: 0.21000000000000002
        }
        },
        {
        &quot;issueName&quot;: &quot;Main dish&quot;,
        &quot;item&quot;: {
        &quot;name&quot;: &quot;Chicken&quot;,
        &quot;evaluation&quot;: 8,
        &quot;normalizedEvaluation&quot;: 0.5599999999999999
        }
        }
        ],
        &quot;concessionValue&quot;: 0.77,
        &quot;type&quot;: &quot;accept&quot;,
        &quot;agentName&quot;: &quot;agent2&quot;
        },
        {
        &quot;choices&quot;: [
        {
        &quot;issueName&quot;: &quot;Staple food&quot;,
        &quot;item&quot;: {
        &quot;name&quot;: &quot;Rice&quot;,
        &quot;evaluation&quot;: 7,
        &quot;normalizedEvaluation&quot;: 0.21000000000000002
        }
        },
        {
        &quot;issueName&quot;: &quot;Main dish&quot;,
        &quot;item&quot;: {
        &quot;name&quot;: &quot;Chicken&quot;,
        &quot;evaluation&quot;: 8,
        &quot;normalizedEvaluation&quot;: 0.5599999999999999
        }
        }
        ],
        &quot;concessionValue&quot;: 0.77,
        &quot;type&quot;: &quot;accept&quot;,
        &quot;agentName&quot;: &quot;agent3&quot;
        }
        ],
        &quot;allAttempts&quot;: [
        // 長いので省略
        ]
        }
        </code></pre>
        <p><code>&quot;isAgreed&quot;: true</code> かつ <code>&quot;attemptsCount&quot;: 8</code> なので 8
        回目の試行で同意できたことがわかる。 このとき、主食は Rice メインディッシュは
        Chicken で同意したようだ。</p>
        <h2>まとめ</h2>
        <p>まだ細かい不具合や機能追加などを行っている途中なのだが、一応動くものができてきた。
        こういう bot がやり取りするようなシステムは初めて作ったので面白かった。</p>
        <p>「Agent がメッセージを送り合う」という特性上、それって channel
        があれば楽そうだなぁと思った結果、調べたところ Node.js には Channel
        機能が組み込まれていた。</p>
        <p><a href="https://nodejs.org/api/diagnostics_channel.html">Node.js v21.6.0 - Diagnostics Channel</a></p>
        <p>便利になったものだ。go 言語の goroutines とか clojure の core.async
        みたいなことが簡易的とはいえ Node.js でできるのはありがたい。</p>
        ]]>
      </content:encoded>
      <pubDate>Sun, 21 Jan 2024 00:00:00 GMT</pubDate>
    </item>
    <item>
      <title>React関係で思うことなど</title>
      <link>https://www.kbaba1001.com/posts/2024011602_react/</link>
      <guid isPermaLink="false">https://www.kbaba1001.com/posts/2024011602_react/</guid>
      <description/>
      <content:encoded>
        <![CDATA[<p>React 18.2.0 以降くらいから Next.js にあるような Server 向けの機能などが色々入るようで、
        僕としてはなんかもうちょっと気楽に SPA 作れる UI ライブラリであれば十分なんだけどなぁ、という微妙な気持ち。</p>
        <p>Next.js も触ってるけど面倒くさくて仕方がない。 Server Side Rendering ってそんなにいいものかなぁ。</p>
        <p>最近入った機能だと Suspense は便利だと思ったけど、 server actions とか use server とかちょっと面倒くさいな。</p>
        <p>まぁ、でも React の内部にデータベースへのアクセスなどのサーバーとしての機能も全部もたせたら便利なのかなぁ。
        それってただのモノリスで、また時代が逆行する気がするけど。。。</p>
        <p>じゃあ、 React 以外のライブラリはどうなんだろうか？</p>
        <p>Preact は少し試したことがあるけど次のような感想。</p>
        <ul>
        <li>Signal は便利 (React で jotai や Recoil など使えば大差ないけど)</li>
        <li>色々と React よりきれいな感じはする</li>
        <li>React ライブラリはダックタイピングで動かすので TypeScript との相性は悪い</li>
        <li>preact-cli は webpack なので微妙だった</li>
        <li>結局 React でよくね？感はすごくある</li>
        </ul>
        <p>もう一つやりたいのは Svelte かなぁ。いまいち流行りきってない感じがあるけど、多分好みではあると思う。</p>
        <p>Solid.js も結局 React でよくね？感を払拭できない。あんま流行ってない気もするし。</p>
        <p>htmx もあんま自分好みじゃないしなぁ</p>
        <p><img src="https://www.kbaba1001.com/img/posts/2024011602/google-trend.png" alt="google trend"></p>
        <p>google trend も見てみたけど、React が圧倒的で次いで Vue, Svelte という感じ。
        やや意外なことに Solid.js は htmx よりも人気がない。</p>
        ]]>
      </content:encoded>
      <pubDate>Tue, 16 Jan 2024 00:00:00 GMT</pubDate>
    </item>
    <item>
      <title>妻に C 言語を教えることになった</title>
      <link>https://www.kbaba1001.com/posts/2024011601_teach-c-language-to-my-wife/</link>
      <guid isPermaLink="false">https://www.kbaba1001.com/posts/2024011601_teach-c-language-to-my-wife/</guid>
      <description/>
      <content:encoded>
        <![CDATA[<p>紆余曲折あって妻に C 言語を教えることになった。
        もともとの妻の希望としては、</p>
        <ul>
        <li>データサイエンティストになりたいからデータ分析とか統計学とか学びたい</li>
        <li>ついでにアルゴリズムとかも知りたい</li>
        </ul>
        <p>ということだったので、 Python / Excel / SQL あたりを教えてみたのだが、
        よく話してみるともうちょっと硬派なことをやりたそうだったので、
        いっそのこと C 言語とか TCP/IP とか Linux とかいわゆる情報系の大学でやるようなことを
        ひととおりやらせてみることにした。</p>
        <p>妻からカリキュラムを作って欲しいと言われたので google classroom で一通り作成することにした。</p>
        <p><img src="https://www.kbaba1001.com/img/posts/2024011601/google-classroom.png" alt="google classroom"></p>
        <p>なるべくネット上の無料で使える教材を使いたかったのだが、書籍のほうがわかりやすいということで何冊か買うことになった。</p>
        <ul>
        <li><a href="https://www.amazon.co.jp/dp/4295011088">統計学の基礎から学ぶ Excel データ分析の全知識</a></li>
        <li><a href="https://amzn.asia/d/7rvthWq">入門 統計学(第 2 版): 検定から多変量解析・実験計画法・ベイズ統計学まで</a></li>
        <li><a href="https://amzn.asia/d/6jZ5Xlx">新・明解 C 言語 入門編 第 2 版</a></li>
        <li><a href="https://amzn.asia/d/eLdiWbB">スッキリわかる Python 入門 第 2 版</a></li>
        <li><a href="https://amzn.asia/d/03PX0mL">現場ですぐに使える！ 最新 Python プログラミング逆引き大全 450 の極意</a></li>
        </ul>
        <p>アルゴリズムやデータ構造を勉強するなら結局 C 言語が一番いいのかもしれない。
        Python のような動的型付け言語では型の概念が理解しづらいし、メモリも意識できない。
        アルゴリズムの説明もなんだかんだ言って C++ とかで説明しているのが多いし。</p>
        <p>ついでに Debian の CUI のみインストールさせて、そこから GUI 環境を構築するという課題をやらせるつもり。
        gentoo や Arch Linux ほど難しくはないしちょうどいい課題だと思うのだが、なぜかこれについてまとめているドキュメントがないんだよなぁ。。。
        自分で書きたいと思いつつなかなか進められていないのでこの機会に作ってしまおうかな。</p>
        <p>まだ買ってないけど良さそうだと思っている本:</p>
        <ul>
        <li><a href="https://amzn.asia/d/0vZBXR9">新・明解 C 言語で学ぶアルゴリズムとデータ構造第 2 版</a></li>
        <li><a href="https://amzn.asia/d/ixP2wm4">基礎から学ぶ React/React Hooks</a></li>
        <li><a href="https://amzn.asia/d/4LU5Ial">体験しながら学ぶ ネットワーク技術入門</a></li>
        <li><a href="https://amzn.asia/d/2IqlFSx">ネットワーク 入門・構築の教科書</a></li>
        <li><a href="https://amzn.asia/d/iWxHu0w">ヤマハルーター＆スイッチによるネットワーク構築 標準教科書</a></li>
        <li>Linux 関係の入門書で何かしらおすすめがほしい (日経 Linux 読む方がいいかなぁ)
        <ul>
        <li><a href="https://amzn.asia/d/aDKwDma">日経 Linux 2023 年 7 月号</a></li>
        </ul>
        </li>
        </ul>
        <p>ここまで来ると Docker とか git とかも知っておいてほしい気もする。
        硬派にやるなら『コンピュータの構成と設計』とかもやっていい気もする。
        応用編として、画像処理、音声処理、AI とかかなぁ。</p>
        ]]>
      </content:encoded>
      <pubDate>Tue, 16 Jan 2024 00:00:00 GMT</pubDate>
    </item>
    <item>
      <title>gRPC, tRPC, GraphQL, REST について</title>
      <link>https://www.kbaba1001.com/posts/2024010501_grpc-trpc-graphql/</link>
      <guid isPermaLink="false">https://www.kbaba1001.com/posts/2024010501_grpc-trpc-graphql/</guid>
      <description>APIのプロトコルについて思うことなど</description>
      <content:encoded>
        <![CDATA[<p>API のプロトコルを色々触ったので雑感まとめ。</p>
        <h2>REST</h2>
        <ul>
        <li><a href="https://developer.mozilla.org/en-US/docs/Glossary/REST">REST - MDN</a></li>
        </ul>
        <p>おそらく現在一番広く使われてる方式が REST だと思う。今更特に言うことはないので省略</p>
        <h2>GraphQL</h2>
        <ul>
        <li><a href="https://graphql.org/">GraphQL</a></li>
        </ul>
        <p>schema 作って各言語で実装を自動生成する。
        最大の特徴はほしい情報をクライアント側からある程度指定できること。
        汎用性が必要で一般公開するような API なら REST より良い気がする。</p>
        <h2>gRPC</h2>
        <ul>
        <li><a href="https://grpc.io/">gRPC</a></li>
        </ul>
        <p>GraphQL のようにクライアント側からの指定はできないものの、 schema (proto ファイル) でサーバーとクライアントの
        やり取りするデータ、API のインタフェースなど一通りのことを定義しておくことができるので、
        ある程度やり取りの内容が決まっている場合には REST よりはかっちり作れるし GraphQL ほど手間でもない。
        わりといいとこ取りをしている気がする。</p>
        <p>こういう必要な schema 定義してよしなにやろうみたいなの昔から色々あるけど、なんかいまいち流行り切らない印象。</p>
        <p>問題は gRPC の proto ファイルから各言語の実装を自動生成するライブラリのクオリティにばらつきがあること。
        これは GraphQL でも言えることだけど、どうしても自動生成系はここがネックになりがち。
        私みたいにマイナー言語使わなければ大して問題にはならないけども……。</p>
        <h2>tRPC</h2>
        <ul>
        <li><a href="https://trpc.io/">tRPC</a></li>
        </ul>
        <p>サーバー、クライアント共に TypeScript なのであれば tRPC が一番楽だと思う。
        TypeScript でインタフェースを定義してそれをサーバー、クライアントで共有する。
        TypeScript に絞っている分、 GraphQL や gRPC のように schema を定義せずにインタフェースをやり取りできるが、
        他の言語への汎用性はない。</p>
        <p>不安要素としては、開発元が Vercel なので最近の Next.js の動きを見ていると tRPC のような仕組みよりは Server Action 推しだと思うので、
        今後メンテがされていくのかどうか疑問だ。
        実際 tRPC が盛り上がった 2 年くらい前からあまり進歩がなさそう。</p>
        <p>良いものだと思うけど採用するかどうかちょっと悩むなぁ……。
        サーバー、クライアント共に TypeScript で、通信周りを楽したいなら割りとありな気がするけど。</p>
        ]]>
      </content:encoded>
      <pubDate>Fri, 05 Jan 2024 00:00:00 GMT</pubDate>
    </item>
    <item>
      <title>Fastify と React の初期セットアップ用リポジトリを作った</title>
      <link>https://www.kbaba1001.com/posts/2024010401_node-init/</link>
      <guid isPermaLink="false">https://www.kbaba1001.com/posts/2024010401_node-init/</guid>
      <description/>
      <content:encoded>
        <![CDATA[<ul>
        <li><a href="https://github.com/neumann-tokyo/fastify-init">GitHub - neumann-tokyo/fastify-init</a></li>
        <li><a href="https://github.com/neumann-tokyo/react-init">GitHub - neumann-tokyo/react-init</a></li>
        </ul>
        <p>express から Fastify に移行したいので初期セットアップ用のリポジトリを作った。
        ついでに React の SPA 構築用のものも用意した。</p>
        <h2>Fastify-init</h2>
        <ul>
        <li><a href="https://github.com/neumann-tokyo/fastify-init">GitHub - neumann-tokyo/fastify-init</a></li>
        </ul>
        <p>Node.js 21 以上の動作を想定。 <a href="https://code.visualstudio.com/docs/devcontainers/containers">VS Code の devcontainer</a> で開発できるようにしてある。</p>
        <p>devcontainer を立ち上げたときに一緒に docker compose で PostgreSQL が起動して即 DB が使える。 migration は <a href="https://github.com/golang-migrate/migrate">golang-migrate/migrate</a> で JS に依存せずに SQL ファイルからマイグレーションする設計にしてある。</p>
        <p>Formatter, Linter として Pritter や ESLint から <a href="https://biomejs.dev/">Biome</a> に変えてみた。
        まだ CSS や HTML などは対応されてないけどいったん良さそう。早いので快適。
        pre-commit ツールも <a href="https://typicode.github.io/husky/">husky</a> から <a href="https://github.com/evilmartians/lefthook">leafhook</a> に変更した。</p>
        <p>テストツールはひとまず node test にしてある。</p>
        <p>DB へのアクセス関係のツールはまだ入れてないけど、個人的な好みとしては <a href="https://kysely.dev/">Kysely</a> が良いと思う。</p>
        <h2>React-init</h2>
        <ul>
        <li><a href="https://github.com/neumann-tokyo/react-init">GitHub - neumann-tokyo/react-init</a></li>
        </ul>
        <p>vite, react-router-dom による React SPA 構成用の初期セットアップリポジトリ。</p>
        <p>chakra-ui で CSS を書かずにデザインを構築可能。</p>
        <p>こちらも biome による Lint, Format が動くようにしてある。</p>
        <p>テストは vitest, happy-dom で動くようにした。フロント用はこれが最近のトレンドとして良い気がする。</p>
        <p>一応、本番環境用に docker compose で nginx や ngrok が動くようにしてあるがこれは完全に自宅サーバー用。</p>
        ]]>
      </content:encoded>
      <pubDate>Thu, 04 Jan 2024 00:00:00 GMT</pubDate>
    </item>
    <item>
      <title>2023年買ってよかったもの</title>
      <link>https://www.kbaba1001.com/posts/2023123101_best_bay/</link>
      <guid isPermaLink="false">https://www.kbaba1001.com/posts/2023123101_best_bay/</guid>
      <description/>
      <content:encoded>
        <![CDATA[<p><img src="https://www.kbaba1001.com/img/posts/2023123101/thumb.png" alt="2023年買ってよかったもの"></p>
        <p>2023 年もあっという間に終わってしまった。今年は節制していたのであまり買い物をしなかったが、買ってよかった物をまとめてみる。</p>
        <h2>机に固定できる電源ハブ</h2>
        <p><a href="https://www.amazon.co.jp/dp/B075M7MDX6?&amp;_encoding=UTF8&amp;tag=samidar-22&amp;linkCode=ur2&amp;linkId=e95ebfdac17828ca193a6f8142aeebde&amp;camp=247&amp;creative=1211"><img src="https://www.kbaba1001.com/img/posts/2023123101/power.png" alt="机に固定できる電源ハブ"><br>サンワサプライ TAP-B53W</a></p>
        <p>最高。机に固定できるので邪魔にならない感じが良い。
        この手の商品もっと増えてほしい。</p>
        <p>だいたいこういうちょっと変わったガジェットはサンワサプライの気がする</p>
        <h2>強力な下水の詰まり直すやつ</h2>
        <a href="https://amzn.asia/d/ieYsLFj" target="_blank">
        <img src="https://www.kbaba1001.com/img/posts/2023123101/pump.png"/><br>
        <div>ローポンプスーパープラス</div>
        </a>
        <p>うちの台所の下水が妙に詰まるので度々下水業者に来てもらっていたのだが、業者が使っていたこの商品を買ったら自力で詰まりを解消できるようになった。</p>
        <h2>レトロフリーク</h2>
        <p><a href="https://www.cybergadget.co.jp/products/4544859100000.html"><img src="https://www.kbaba1001.com/img/posts/2023123101/retro-freak.png" alt="レトロフリーク"><br>レトロフリーク</a></p>
        <p>ファミコンとかメガドライブなどのソフトを動かせる互換機。</p>
        <p><img src="https://www.kbaba1001.com/img/posts/2023123101/gw.jpg" alt="桃鉄"></p>
        <p>ずっと桃鉄をやっていた。</p>
        <h2>マウスコンピュータのパソコン</h2>
        <p><a href="https://www.mouse-jp.co.jp/store/g/gg-tune-p5-rt/"><img src="https://www.kbaba1001.com/img/posts/2023123101/mouse-computer.jpg" alt="G-Tune P5-RT"><br>マウスコンピュータ G-Tune P5-RT</a></p>
        <p>今年はパソコンも買い換えた。それまで Surface 7 を使っていたのだが、開発のメイン機として使うには Surface は力不足だった。たまに熱くなりすぎてシャットダウンするような状況だったので、色々諦めてパフォーマンスに全ふりすることにした。</p>
        <p>調べた結果マウスコンピュータが結構コスパがよく、カスタマイズもかなり自由にできるので上記のマシンにした。
        メモリは 64GB 、SSD は 2TB に増設してある。
        残念なのはキーボードが日本語配列しか選べないことなのだが、常に外部キーボードを使うことで解決した。
        また、 Windows Hello 対応のカメラも埋め込みできないので、外付けのやつを使っている。</p>
        <p><a href="https://www.mouse-jp.co.jp/store/g/gmouse-cm02/"><img src="https://www.kbaba1001.com/img/posts/2023123101/cm02-01.jpg" alt="顔認証カメラ CM02"><br>顔認証カメラ CM02</a></p>
        <p>残念なことにこのカメラも販売終了したようだ。 Windows Hello 対応カメラとしては安くてよかったのだが……。</p>
        <p>昨今、 AI 関係の開発も増えていて Nvidia の GPU が必須になってきているため、 GeForce RTX 3050 Ti GPU を搭載していることが重要だった。</p>
        <p>おかげで最近はこのマシンのみ使っていて、デスクトップ PC を使わなくなったのでそっちはサーバーに生まれ変わった。
        使うマシンを１つにすると色々と有償ソフトのライセンスとかが安く済むので便利だった。</p>
        <p>ただ、デカくて重い。あまり気楽に持ち運ぶ感じじゃないのがちょっとしんどい。</p>
        <h2>エナージェル 7 色</h2>
        <p><a href="https://www.pentel.co.jp/news/20231004/"><img src="https://www.kbaba1001.com/img/posts/2023123101/energel.webp" alt="エナージェル 7 色"><br>エナージェル 7 色</a></p>
        <p>ボールペンはエナージェルをずっと使っている。逆に言うと他のペンを全くと言っていいほど使っていない。</p>
        <p>で、黒っぽいけど微妙に色が違うという万年筆のインクみたいな色セットが販売されたので、発売日に文房具店ですぐに買った。</p>
        <p>エナージェルの書き心地で万年筆並みに色が使えるのが楽しくて最高。太さ 0.7 と 0.5 でどちらが良いか永遠に結論が出ない。</p>
        <p>今年は結構色々な文房具を買った気がする。</p>
        <h2>ノートのように使えるバインダー</h2>
        <p><a href="https://www.kokuyo-st.co.jp/stationery/campus-notebinder/"><img src="https://www.kbaba1001.com/img/posts/2023123101/note.jpg" alt="ノートのように使えるバインダー"><br>ノートのように使えるバインダー</a></p>
        <p>あまりルーズリーフは使ってこなかったのだが、このバインダーが薄くて持ち運びがよいので使い始めた。
        B5 サイズは僕がいつも持ち歩いているカバンに入るので何冊か買って使っている。</p>
        <h2>おわり</h2>
        <p>今年はあまり買い物をしなかった。だいたい必要なものは手に入っている感じもする。</p>
        ]]>
      </content:encoded>
      <pubDate>Sun, 31 Dec 2023 00:00:00 GMT</pubDate>
    </item>
    <item>
      <title>クリスマスと餃子</title>
      <link>https://www.kbaba1001.com/posts/2023122501_christmas/</link>
      <guid isPermaLink="false">https://www.kbaba1001.com/posts/2023122501_christmas/</guid>
      <description/>
      <content:encoded>
        <![CDATA[<p><img src="https://www.kbaba1001.com/img/posts/2023122501_christmas.jpg" alt="クリスマスと餃子"></p>
        <p>12 月 23 日くらいからずっと餃子を作って焼いたり煮たりしていた。</p>
        <p>家で餃子を包むのは初めてだったけど手分けして包むのは結構楽しかった。
        今年の年末年始はなるべく家に引きこもっていたい。</p>
        ]]>
      </content:encoded>
      <pubDate>Mon, 25 Dec 2023 00:00:00 GMT</pubDate>
    </item>
    <item>
      <title>アニメを溜めている</title>
      <link>https://www.kbaba1001.com/posts/2023122201_otakatsu/</link>
      <guid isPermaLink="false">https://www.kbaba1001.com/posts/2023122201_otakatsu/</guid>
      <description>年末年始休みが楽しみ</description>
      <content:encoded>
        <![CDATA[<p>忙しさもあり見たいアニメが溜まっている。
        年末年始休みに一気にみたいなぁ。ゆっくりしながら。</p>
        <ul>
        <li>葬送のフリーレン</li>
        <li>僕やば</li>
        <li>水星の魔女</li>
        </ul>
        <p>あたり見たい。</p>
        <p>１月からのアニメも面白そうなのが多いし楽しみすぎる。ぬおー。</p>
        <p>少しずつそういうものを楽しむ余裕を取り戻していきたい。</p>
        <p>最近は節約であまり漫画を買ってないからオタ活が滞っている。
        d アニメストアも解約してしまったし。悲しい。</p>
        <p>『ダンジョン飯』のアニメが楽しみすぎて、劇場先行上映を見てきた。
        とても良かった。声も原作通り。連続２クールが楽しみすぎる。
        ネタバレするとセンシのパンチラがあった。
        センシ格好良くて好き。あとやっぱりマルシル。</p>
        <p>僕やばと『その着せ替え人形は恋をする』が同じくらい好き。
        『付き合ってあげてもいいかな』もアニメ化してほしいな。
        エッチシーン多いから無理かな。最近百合アニメ多いからいけるかもしれない。</p>
        <p>『乙嫁語り』のワイド版ももったいなくて開封してないけど、そろそろちゃんと読もう。</p>
        <p>来年は収入を復活させてオタ活を気兼ねなくできるようにしたいなぁ。</p>
        ]]>
      </content:encoded>
      <pubDate>Fri, 22 Dec 2023 00:00:00 GMT</pubDate>
    </item>
  </channel>
</rss>