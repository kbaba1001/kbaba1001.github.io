<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:wfw="http://wellformedweb.org/CommentAPI/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:sy="http://purl.org/rss/1.0/modules/syndication/" xmlns:slash="http://purl.org/rss/1.0/modules/slash/" version="2.0">
  <channel>
    <title>kbaba1001 ブログ</title>
    <link>https://www.kbaba1001.com/</link>
    <atom:link href="https://www.kbaba1001.com/feed.rss" rel="self" type="application/rss+xml"/>
    <description>Clojure 好きなプログラマ kbaba1001 のブログ</description>
    <lastBuildDate>Sun, 17 Dec 2023 15:00:00 GMT</lastBuildDate>
    <language>ja_JP</language>
    <generator>Lume v2.0.1</generator>
    <item>
      <title>サーバー内での docker compose up をローカルから行う方法</title>
      <link>https://www.kbaba1001.com/posts/2024020101_docker-context/</link>
      <guid isPermaLink="false">https://www.kbaba1001.com/posts/2024020101_docker-context/</guid>
      <description/>
      <content:encoded>
        <![CDATA[<p>まずサーバーで docker や docker compose が動くようにしておく。 その後、</p>
        <pre><code class="language-bash">$ DOCKER_HOST=&quot;ssh://user@remotehost&quot; docker compose up -d
        </code></pre>
        <p>するだけで遠隔サーバーで docker container を起動できる。</p>
        <p>知らなかった...。</p>
        <p>さらに docker context を使うと DOCKER_HOST を変えなくても指定した環境で docker
        compose up できる。</p>
        <pre><code class="language-bash">$ docker context create remote --docker &quot;host=ssh://user@remotemachine&quot;
        $ docker --context remote compose up -d
        </code></pre>
        <div class="post-learge-font">
        便利すぎでは～！！
        </div>
        <p>もちろん <code>~/.ssh/config</code> に設定した Host 名も使える。 僕の場合、 <code>~/.ssh/config</code>
        に次のような設定がある。</p>
        <pre><code class="language-bash">host monday
        HostName xxx.xxx.xxx.xxx
        User xxxxxxxx
        ForwardAgent yes
        IdentityFile ~/.ssh/id_ed25519
        </code></pre>
        <p>ので</p>
        <pre><code class="language-bash">$ DOCKER_HOST=&quot;ssh://monday&quot; docker compose up -d
        </code></pre>
        <p>でよい。</p>
        <p>参考:
        <a href="https://www.docker.com/blog/how-to-deploy-on-remote-docker-hosts-with-docker-compose/">How to deploy on remote Docker hosts with docker-compose</a></p>
        <p>本格的に運用するなら k3s とかで k8s 環境を作ったほうが良さそう。</p>
        ]]>
      </content:encoded>
      <pubDate>Thu, 01 Feb 2024 00:00:00 GMT</pubDate>
    </item>
    <item>
      <title>自宅サーバーに github、 dropbox、 ngrok みたいなのがほしい</title>
      <link>https://www.kbaba1001.com/posts/2024013101_on-premises/</link>
      <guid isPermaLink="false">https://www.kbaba1001.com/posts/2024013101_on-premises/</guid>
      <description/>
      <content:encoded>
        <![CDATA[<p>自宅サーバーの活用について考えるとやっぱりファイル共有みたいなことがしたいし、
        どうせなら git サーバーとして push/pull したい。 固定 IP が面倒くさくて ngrok
        を使っているが、そこそこお値段がするのでどうせならここもオープンソースにしたい。</p>
        <p>みたいなことを考えた結果、次を導入しようと思っている。</p>
        <ul>
        <li>ファイル共有: <a href="https://onionshare.org/">OnionShare</a></li>
        <li>git サーバー: <a href="https://github.com/gitbucket/gitbucket">GitBucket</a></li>
        <li>トンネリング: <a href="https://github.com/fatedier/frp">frp</a></li>
        </ul>
        <h3>ファイル共有 (Dropbox alternatives)</h3>
        <p>あまりクラウドに置いておきたくないデータがいくつかあり、そういうのを自宅サーバーに置いておきたいのだが、
        単に SSH するだけだとファイルの閲覧が不便だったりするので、 Dropbox
        的に使えるやつがほしくなった。</p>
        <p><a href="https://min.io/">Minio</a> が GUI ツールもあるのでそれでもいいのだが、調べたら
        <a href="https://onionshare.org/">OnionShare</a>
        というのがスマホアプリもあって良さそうな気がしたので試してみたい。</p>
        <h3>git サーバー (Github alternatives)</h3>
        <p><a href="https://about.gitlab.com/">GitLab</a>
        とかが有名だがそんなに高機能じゃなくていいのと、
        前から少し気になっていることもあり
        <a href="https://github.com/gitbucket/gitbucket">GitBucket</a> を導入予定。
        これは確か日本人が作っていたはず。</p>
        <h3>トンネリング (ngrok alternatives)</h3>
        <p><a href="https://ngrok.com/">ngrok</a> の production apps プランを使っているのだが、１つの
        domain を作るたびに月 $15
        かかるので何個かやっているとそれなりの出費になってきた。</p>
        <p>調べたらめちゃくちゃしっかりしたまとめが作ってあった。
        <a href="https://github.com/anderspitman/awesome-tunneling">awesome-tunneling</a></p>
        <p>これによると、 CloudFlare Tunnel がおすすめ、 self-host したいなら
        <a href="https://github.com/fatedier/frp">frp</a> という感じなのでおすすめに従って、 frp
        を試してみようと思う。</p>
        <h3>雑感</h3>
        <p>自宅サーバーがあると電気代を無駄にしたくないので活用したくなる。</p>
        ]]>
      </content:encoded>
      <pubDate>Wed, 31 Jan 2024 00:00:00 GMT</pubDate>
    </item>
    <item>
      <title>いつの間にか AtCoder で Babashka が動くようになっていた</title>
      <link>https://www.kbaba1001.com/posts/2024012902_babashka-at-coder/</link>
      <guid isPermaLink="false">https://www.kbaba1001.com/posts/2024012902_babashka-at-coder/</guid>
      <description/>
      <content:encoded>
        <![CDATA[<p><img src="https://www.kbaba1001.com/img/posts/2024012902/atcoder.png" alt="AtCoder"></p>
        <div class="post-learge-font">
        <p>いつの間にか <a href="https://atcoder.jp/">AtCoder</a> で
        <a href="https://github.com/babashka/babashka">Babashka</a> が使えるようになっている！！！</p>
        <p>めちゃくちゃ嬉しい！！</p>
        <p>AtCoder 始めます！！</p>
        </div>
        <p>どういうことかというと、今まで AtCoder で普通の Clojure
        の実行はできていたのですが、どうも起動時間も含めて実行速度
        として計算されていたらしく、とんでもなく不利でした。</p>
        <p>一方 Babashka は GraalVM を使った起動がめちゃくちゃ速い Clojure
        の実行環境で、これが AtCoder で使えたらいいのになぁと多くの Clojurians
        は思ってました。</p>
        <div class="post-learge-font">
        <p>で、それが叶いました。</p>
        <p>最高ー！！</p>
        </div>
        ]]>
      </content:encoded>
      <pubDate>Mon, 29 Jan 2024 00:00:00 GMT</pubDate>
    </item>
    <item>
      <title>2 月 25 日 (日) に「１か月間全力で個人サイトを作ろうハッカソン、発表会」を開催します</title>
      <link>https://www.kbaba1001.com/posts/2024012901_hackathon/</link>
      <guid isPermaLink="false">https://www.kbaba1001.com/posts/2024012901_hackathon/</guid>
      <description/>
      <content:encoded>
        <![CDATA[<p><img src="https://www.kbaba1001.com/img/posts/2024012901_hackathon.jpg" alt="2024012901_hackathon.jpg"></p>
        <p>個人サイトを<strong>全力で</strong>作りましょう！</p>
        <p><strong>全力</strong>とは自分の持てる技術の全てを費やすという意味です。</p>
        <p>いにしえの個人サイトといえば、</p>
        <ul>
        <li>アクセスカウンター</li>
        <li>Web 拍手</li>
        <li>掲示板</li>
        <li>チャット</li>
        <li>相互リンク</li>
        </ul>
        <p>など当時の技術（だいたい CGI）をフル動員した個人サイトがたくさんあったものです。
        徐々に Twitter などの SNS に移り変わっていきましたが、それまでは皆 HTML とか CSS
        とか 自力で勉強して個人サイトを作ってました。
        今にして思えばすごい時代です。プログラマでもない人たちがこれら技術を自力でなんとか勉強して
        いたわけですから。</p>
        <p>さて、そんな中なぜ今更個人サイトを作るのかというと、個人的に 昨今 Twitter が X
        になったりしてなんとなく SNS やクラウドサービスに
        疑問を持つような機会が増えてきました。
        結局信用できるのは自分で運用しているものだけかなぁ、みたいな気持ちがあります。</p>
        <p>現在このブログは静的サイトジェネレータを使って Github Pages で公開していますが、
        もっと掲示板などの機能を作ってみたくなってきました。</p>
        <p>一人で作っても良いのですが、誰か一緒にやりたい方がいたら嬉しいのでハッカソンにすることにしました。</p>
        <h2>ハッカソンの概要</h2>
        <p>今からだいたい１ヶ月後の 2 月 25 日 (日) に
        「<a href="https://connpass.com/event/309089/">１か月間全力で個人サイトを作ろうハッカソン、発表会</a>」
        を開催します。</p>
        <p>このときに、各参加者に自分で作った個人サイトを発表していただきます。</p>
        <p>なので、 2 月 25 日 (日)までに各自、全力で個人サイトを作ってください。</p>
        <h3>参加方法</h3>
        <ul>
        <li>「<a href="https://connpass.com/event/309089/">１か月間全力で個人サイトを作ろうハッカソン、発表会</a>」に申し込んでください。</li>
        <li>参加費等はありません。</li>
        <li>いつでも参加表明して頂いて大丈夫です（例えば発表会の前日から数時間で作った、でも OK です）</li>
        </ul>
        <h3>発表会当日</h3>
        <ul>
        <li>オンライン (google meet) で開催します。(URL は connpass
        の参加者にのみ公開します)</li>
        <li>顔出しは任意です。</li>
        <li>作品を参加者自身でプレゼンして頂きます。
        <ul>
        <li>発表時間は参加人数にもよりますが 15 分程度を想定</li>
        </ul>
        </li>
        <li>主催者の独断で審査を行い、優勝者を決めます。</li>
        </ul>
        <h3>作品の条件</h3>
        <ul>
        <li><strong>インターネット上に公開されており、 URL (または IP アドレス)
        でアクセスできることを必須とします。</strong></li>
        <li>個人サイトのコンテツ内容は自由です。 R-18
        を含む場合はそのページを開く前に年齢確認をするなど配慮をお願いします。
        <ul>
        <li>発表会では全年齢向けのページのみ表示し、審査の対象とします</li>
        </ul>
        </li>
        </ul>
        <h3>審査について</h3>
        <ul>
        <li>発表会の最後に、各参加者の発表会の内容を元にして主催者の独断で優勝者を決めます</li>
        <li>評価基準として技術点、個人サイトらしさ、コンテンツの面白さ、将来性などを考慮します</li>
        <li>優勝者には景品として ◯◯◯◯ を差し上げます (TODO 景品決める)</li>
        </ul>
        ]]>
      </content:encoded>
      <pubDate>Mon, 29 Jan 2024 00:00:00 GMT</pubDate>
    </item>
    <item>
      <title>いにしえのホームページを Clojure の最先端技術で作りたい</title>
      <link>https://www.kbaba1001.com/posts/2024012501_homepage/</link>
      <guid isPermaLink="false">https://www.kbaba1001.com/posts/2024012501_homepage/</guid>
      <description/>
      <content:encoded>
        <![CDATA[<p>このブログを運用し始めて約１か月。</p>
        <p>さっそくアクセスカウンターとか掲示板とか欲しくなってきた。 Twitter
        もやめてしまったのでどうせならマイクロポストの機能もほしい。</p>
        <p>そんな感じの個人サイトを Clojure で作ろうかと思っている。</p>
        <h3>サーバーサイド開発について</h3>
        <p>サーバーサイドを今まで <a href="https://github.com/duct-framework/duct">Duct</a>
        で作ってきたのだが、別に Duct 使わなくてもいいんじゃないかなと思えてきた。 Duct
        は <code>defmethod</code> を活用して関数を疎結合にしてシステムを構築するのだが、</p>
        <ul>
        <li>別に毎回そこまで疎結合じゃなくてもいい</li>
        <li>むしろコードジャンプできなくて辛い</li>
        <li>edn ファイルでシステムを定義するのが面倒くさい</li>
        </ul>
        <p>というあたりでやめようと思った。</p>
        <p>ではどうするかというと、他の言語でよくやるのと同じようにオートリロードできれば十分だと思う。
        調べたら
        <a href="https://ring-clojure.github.io/ring/ring.middleware.reload.html">ring にはそもそもオートリロードの機能がある</a>
        ようなのでこれを使いたい。
        <a href="https://github.com/weavejester/ring-refresh">ring-refresh</a>
        というライブラリもあるし。
        <a href="https://practical.li/clojure-web-services/projects/leiningen/todo-app/reloading-the-application/">使い方</a></p>
        <p>あとは <a href="https://github.com/metosin/reitit">reitit</a>
        とかでルーティングを作れば十分だろう。 DB
        コネクションの各ファイルへの受け渡しだけなんとかする。 必要であればここだけ
        <a href="https://github.com/clojure/core.async">core.async</a> の
        <a href="https://clojuredocs.org/clojure.core.async/pipeline">pipeline</a>
        とかで疎結合にしておけばいい。</p>
        <p>参考:
        <a href="https://boxofpapers.hatenablog.com/entry/core_async">Clojure + core.async による非同期＆並列プロセスの世界</a></p>
        <h3>フロントエンド開発について</h3>
        <p>今まで <a href="https://github.com/thheller/shadow-cljs">shadow-cljs</a> +
        <a href="https://github.com/lilactown/helix">helix</a>
        構成を試してきてこれはかなり快適だったのだが、新しい試みとして
        <a href="https://github.com/squint-cljs/squint">Squint</a> を試したいと思っている。</p>
        <p>Squint は ClojureScript を js に変換するコンパイラで、最大の特徴として <strong>Java
        に依存していない!!</strong>。 つまり TypeScript のコンパイラなどと同様に package.json
        に書いておけば、それだけで cljs を js に変換できる。 shadow-cljs
        がやりたかったことをもう一歩進めた感じだ。 Squint は js
        に寄っているが、もっと標準的な ClojureScript に寄せた
        <a href="https://github.com/squint-cljs/cherry">Cherry</a> というのもある。 Squint を使えば
        React や Vite などのフロントエンド開発で使われるツールを
        そのまま使うことができる。<a href="https://github.com/squint-cljs/squint/tree/main/examples/vite-react">examples/vite-react</a></p>
        <p>これらは <a href="https://github.com/babashka/babashka">babashka</a> の作成者として有名な
        borkdude
        さんの作品で、彼は本当にこういうものを作るのが上手だしまめに作っていると思う。
        尊敬しかない。</p>
        <p>Squint
        はまだ本番環境で使うことを推奨していないようだけど、まぁ個人サイトのフロントエンドを作るくらいなら後で
        Squint の仕様が変わったとしてもあまり困らない気がする。 Clojure コミュニティの
        Slack 見ているとすでに結構出来上がっている雰囲気あるし。</p>
        <p>Squint は CljureScript の歴史を変える可能性があるプロダクトだと思っているので
        ぜひとも試してみたい。 今までの ClojureScript では面倒になる <code>Promise</code>,
        <code>async/await</code> まわりも楽にかけそうだし、 <code>jsx</code> との統合も魅力的だ。 一方で nREPL
        や Macros も使える。</p>
        <p>最高では～！</p>
        ]]>
      </content:encoded>
      <pubDate>Thu, 25 Jan 2024 00:00:00 GMT</pubDate>
    </item>
    <item>
      <title>久々に買ってみた技術書</title>
      <link>https://www.kbaba1001.com/posts/2024012201_technologies-books/</link>
      <guid isPermaLink="false">https://www.kbaba1001.com/posts/2024012201_technologies-books/</guid>
      <description/>
      <content:encoded>
        <![CDATA[<p>久しぶりに Web 系の技術書を買ってみた。</p>
        <p><img src="https://www.kbaba1001.com/img/posts/2024012201/tech-books.jpg" alt="tech-books"></p>
        <ul>
        <li>Rust と WebAssembly によるゲーム開発</li>
        <li>Web パフォーマンスチューニング ISUCON</li>
        <li>フロントエンド開発のためのセキュリティ入門</li>
        <li>フロントエンド開発のためのテスト入門</li>
        </ul>
        <p>長らく技術書を買ったり読んだりしてなかった。だいたいのことはライブラリとかの公式サイト読む方がいいし。
        最近少し大き目の本屋に行く機会があって、久しぶりに技術書を見ていたら色々と良さそうな本もあったので、
        久しぶりに自分のために買ってみることにした。</p>
        <p>『フロントエンド開発のためのテスト入門』と『フロントエンド開発のためのセキュリティ入門』の２冊は前から気になっていたので購入。
        そういえばあまりフロントのテスト書いてなかったわ。 js-dom とか一応入れるだけ入れてちゃんとした React コンポーネントのテスト書いたことないかも。という自戒も込めて。</p>
        <p>『フロントエンド開発のためのセキュリティ入門』の方は答え合わせのつもりで購入。たぶんだいたい知っているとは思うけど、この際知識を整理しておきたい。</p>
        <p>『Web パフォーマンスチューニング ISUCON』は Amazon で見つけて衝動買い。
        パフォーマンスチューニングも意外と知らないことある気がした。
        CDN とかあんま詳しくないし。</p>
        <p>『Rust と WebAssembly によるゲーム開発』は Rust と WebAssembly の知識が両方 0 なのだが、
        WebAssembly に GC がないので Rust のような GC がなくても現代的な開発ができる言語が人気ときいて
        やってみたくなったため。
        ゲーム開発をする予定はないけど、フロントではちょっと重い処理をなんとか速くしたいみたいなときに
        WebAssembly 使えたら面白いかもなぁ、という気持ち。</p>
        <p>何にせよ自分のために技術の本を買うのは結構久々で、普通に読むのが楽しみだ。
        新人教育的な目的で購入した本は結構あるし、一時期は O'Reilly online で英語の本とか読んでたけど、
        最近はそういうのもすっかりやらなくなってしまった。</p>
        ]]>
      </content:encoded>
      <pubDate>Mon, 22 Jan 2024 00:00:00 GMT</pubDate>
    </item>
    <item>
      <title>自動交渉のライブラリを作った</title>
      <link>https://www.kbaba1001.com/posts/2024012101_auto-negotiator/</link>
      <guid isPermaLink="false">https://www.kbaba1001.com/posts/2024012101_auto-negotiator/</guid>
      <description/>
      <content:encoded>
        <![CDATA[<p><a href="https://github.com/neumann-tokyo/auto_negotiator">Auto Negotiator</a>
        というライブラリを TypeScript で作った。</p>
        <p>npm package はこちら:
        <a href="https://www.npmjs.com/package/auto_negotiator">auto_negotiator</a></p>
        <h2>自動交渉の概要</h2>
        <p>自動交渉については ↓
        の記事などがわかりやすい（というかこれ以外あんまなかった）。</p>
        <p><a href="https://engineering.mercari.com/blog/entry/2017-12-07-103000/">自動交渉 AI から見る&quot;AI 同士がつながる世界&quot;</a></p>
        <p>自動交渉は交渉を行うエージェントを数体作成して、それらのエージェントの希望を考慮しつつ満場一致になる選択肢を導き出すというもの。</p>
        <p>例えば、夕食のメニューを考えるときに、</p>
        <ul>
        <li>主食
        <ul>
        <li>ご飯</li>
        <li>パン</li>
        <li>麺</li>
        </ul>
        </li>
        <li>メインディッシュ
        <ul>
        <li>ステーキ</li>
        <li>魚</li>
        <li>チキン</li>
        </ul>
        </li>
        </ul>
        <p>みたいな選択肢があって、エージェント A は
        <code>{主食: ご飯, メインディッシュ: ステーキ}</code> がよく、エージェント B は
        <code>{主食: ご飯, メインディッシュ: 魚}</code>
        がよいという意見を持っている場合に、エージェント A, B
        がある程度納得して同意（満場一致）できる献立を考えるというもの。</p>
        <h2>プログラムでの表現</h2>
        <p>自動交渉を行うには、エージェントとトピックが必要だ。
        ライブラリの本体とは別にサンプルコードも用意したので、以下はサンプルコードを元にして説明する。</p>
        <h3>トピック</h3>
        <p>まずトピックについて説明する。</p>
        <p><a href="https://github.com/neumann-tokyo/auto_negotiator/blob/main/sample/topic/dinner/agent1.ts">https://github.com/neumann-tokyo/auto_negotiator/blob/main/sample/topic/dinner/agent1.ts</a></p>
        <pre><code class="language-typescript">import { Topic } from &quot;../../../src/types&quot;;
        
        export const topic: Topic = {
        name: &quot;Dinner&quot;,
        description: &quot;What should we have dinner?&quot;,
        discount_factor: 0.1,
        reservation: 0.3,
        issues: [
        {
        name: &quot;Staple food&quot;,
        weight: 0.3,
        items: [
        {
        name: &quot;Rice&quot;,
        evaluation: 7,
        },
        {
        name: &quot;Noodles&quot;,
        evaluation: 2,
        },
        {
        name: &quot;Bread&quot;,
        evaluation: 1,
        },
        ],
        },
        {
        name: &quot;Main dish&quot;,
        weight: 0.7,
        items: [
        {
        name: &quot;Steak&quot;,
        evaluation: 1,
        },
        {
        name: &quot;Fish&quot;,
        evaluation: 1,
        },
        {
        name: &quot;Chicken&quot;,
        evaluation: 8,
        },
        ],
        },
        ],
        };
        </code></pre>
        <p>上記のように夕食の献立というトピックにたいして、どのような意見を持っているかを決める。
        まず、この agent1 は主食 (Staple food) とメインディッシュ (Main dish)
        に対して、それぞれ 0.3 と 0.7 の重み (weight) をつけている。 weight
        は全体で合計が 1.0 になるように設定する必要があり、どの issue
        に大して優先したいかを示す。 ようするに、 agent1 はメインディッシュに関して 70%
        優先したいと考えている。逆に言えば主食に関しては譲歩しやすい。</p>
        <pre><code>  name: &quot;Staple food&quot;,
        weight: 0.3,
        
        name: &quot;Main dish&quot;,
        weight: 0.7,
        </code></pre>
        <p>次に、issue の中について見てみると <code>items</code> に選択肢として Rice, Noodles, Bread
        があり、その evaluation が 7, 2, 1 となっている。 evaluation については Integer
        でどのような数値を置いても良いが、合計が 10 や 100
        になるようにするとわかりやすい。
        （内部で処理する際はこの数値に重みを付けて正規化する）</p>
        <pre><code class="language-typescript">{
        name: &quot;Staple food&quot;,
        weight: 0.3,
        items: [
        {
        name: &quot;Rice&quot;,
        evaluation: 7,
        },
        {
        name: &quot;Noodles&quot;,
        evaluation: 2,
        },
        {
        name: &quot;Bread&quot;,
        evaluation: 1,
        },
        ],
        },
        </code></pre>
        <p>evaluation
        の値が大きいほどその選択肢にしたいという意思が強くなるため、上記の場合では
        agent1 は Rice を食べたいという意思が強いことがわかる。</p>
        <h3>エージェント</h3>
        <p>エージェントは他のエージェントからの提案やトピックを元にしてどのように自分の意見を主張していくかを決定づけるものだ。</p>
        <p>ソースコードを元に説明する。</p>
        <p><a href="https://github.com/neumann-tokyo/auto_negotiator/blob/main/sample/agents/sample-agent.ts">https://github.com/neumann-tokyo/auto_negotiator/blob/main/sample/agents/sample-agent.ts</a></p>
        <pre><code class="language-typescript">import * as helper from &quot;../../src/helper&quot;;
        import * as types from &quot;../../src/types&quot;;
        
        // この関数は試行のたびに呼び出される。
        // 引数には全体の状況や自分のトピックがはいってきて、自分の意見を返すとそれが他のエージェントにも伝わる。
        export function sampleAgent({
        data: { id, attempts, attemptsCount },
        normalizedTopic,
        }: types.ActionFnParams): types.ActionFnResponse {
        // 現在の試行における他のエージェントからの提案などがはいっている
        const currentAttempt = helper.currentAttempt({ id, attempts });
        
        // 試行回数を元にして譲歩値を設定する。 1.0 - progress なので徐々に譲歩値は下がっていく。
        // つまり、他からの意見に同意しやすくなる
        const progress = helper.progress({ id, attemptsCount });
        const concessionValue = 1.0 - progress;
        
        for (const status of currentAttempt) {
        if (status.type === types.AtemptType.Offer) {
        const anotherConcessionValue = helper.choicesToConcessionValue({
        choices: status.choices,
        });
        
        // 相手からの提案のほうが自分の譲歩値より高いのであれば同意する
        if (concessionValue &lt; anotherConcessionValue) {
        return {
        id,
        choices: status.choices,
        concessionValue: anotherConcessionValue,
        type: types.AtemptType.Accept,
        };
        }
        }
        }
        
        // 同意できない場合に自分の意見を作成する
        const { choices, threshold } = helper.concessionValueToChoices({
        normalizedTopic,
        concessionValue,
        });
        return {
        id,
        choices,
        concessionValue,
        type: types.AtemptType.Offer,
        };
        }
        </code></pre>
        <p>上記はエージェントのサンプルでしかなく、もっと自由に作って良い。</p>
        <h3>自動交渉の実行</h3>
        <p>最後はエージェントとトピックを元にして自動交渉を行う。</p>
        <p><a href="https://github.com/neumann-tokyo/auto_negotiator/blob/main/sample/run.ts">https://github.com/neumann-tokyo/auto_negotiator/blob/main/sample/run.ts</a></p>
        <pre><code class="language-typescript">import { prettyPrint } from &quot;../src/helper&quot;;
        import * as negotiator from &quot;../src/index&quot;;
        import { sampleAgent } from &quot;./agents/sample-agent&quot;;
        import { topic as agent1Topic } from &quot;./topic/dinner/agent1&quot;;
        import { topic as agent2Topic } from &quot;./topic/dinner/agent2&quot;;
        import { topic as agent3Topic } from &quot;./topic/dinner/agent3&quot;;
        
        // これは任意の値を設定して良い
        const channelName = &quot;dinner&quot;;
        
        // エージェントとそのトピックを登録する
        negotiator.defineAgent({
        channelName: channelName,
        agentName: &quot;agent1&quot;,
        topic: agent1Topic,
        actionFn: sampleAgent,
        });
        negotiator.defineAgent({
        channelName: channelName,
        agentName: &quot;agent2&quot;,
        topic: agent2Topic,
        actionFn: sampleAgent,
        });
        negotiator.defineAgent({
        channelName: channelName,
        agentName: &quot;agent3&quot;,
        topic: agent3Topic,
        actionFn: sampleAgent,
        });
        
        // 自動交渉を行う。試行回数（attemptsCount）は 30 回、エージェント数 (agentsCount) は 3 体
        const result = negotiator.negotiate({
        channelName,
        attemptsCount: 30,
        agentsCount: 3,
        });
        
        // 結果の表示
        prettyPrint(result);
        </code></pre>
        <p>自動交渉の結果は次のようになる。</p>
        <p><a href="https://github.com/neumann-tokyo/auto_negotiator/blob/main/sample/result.json">https://github.com/neumann-tokyo/auto_negotiator/blob/main/sample/result.json</a></p>
        <pre><code class="language-json">{
        &quot;isAgreed&quot;: true,
        &quot;id&quot;: 7,
        &quot;attemptsCount&quot;: 8,
        &quot;conclusion&quot;: [
        {
        &quot;choices&quot;: [
        {
        &quot;issueName&quot;: &quot;Staple food&quot;,
        &quot;item&quot;: {
        &quot;name&quot;: &quot;Rice&quot;,
        &quot;evaluation&quot;: 7,
        &quot;normalizedEvaluation&quot;: 0.21000000000000002
        }
        },
        {
        &quot;issueName&quot;: &quot;Main dish&quot;,
        &quot;item&quot;: {
        &quot;name&quot;: &quot;Chicken&quot;,
        &quot;evaluation&quot;: 8,
        &quot;normalizedEvaluation&quot;: 0.5599999999999999
        }
        }
        ],
        &quot;concessionValue&quot;: 0.7666666666666666,
        &quot;type&quot;: &quot;offer&quot;,
        &quot;agentName&quot;: &quot;agent1&quot;
        },
        {
        &quot;choices&quot;: [
        {
        &quot;issueName&quot;: &quot;Staple food&quot;,
        &quot;item&quot;: {
        &quot;name&quot;: &quot;Rice&quot;,
        &quot;evaluation&quot;: 7,
        &quot;normalizedEvaluation&quot;: 0.21000000000000002
        }
        },
        {
        &quot;issueName&quot;: &quot;Main dish&quot;,
        &quot;item&quot;: {
        &quot;name&quot;: &quot;Chicken&quot;,
        &quot;evaluation&quot;: 8,
        &quot;normalizedEvaluation&quot;: 0.5599999999999999
        }
        }
        ],
        &quot;concessionValue&quot;: 0.77,
        &quot;type&quot;: &quot;accept&quot;,
        &quot;agentName&quot;: &quot;agent2&quot;
        },
        {
        &quot;choices&quot;: [
        {
        &quot;issueName&quot;: &quot;Staple food&quot;,
        &quot;item&quot;: {
        &quot;name&quot;: &quot;Rice&quot;,
        &quot;evaluation&quot;: 7,
        &quot;normalizedEvaluation&quot;: 0.21000000000000002
        }
        },
        {
        &quot;issueName&quot;: &quot;Main dish&quot;,
        &quot;item&quot;: {
        &quot;name&quot;: &quot;Chicken&quot;,
        &quot;evaluation&quot;: 8,
        &quot;normalizedEvaluation&quot;: 0.5599999999999999
        }
        }
        ],
        &quot;concessionValue&quot;: 0.77,
        &quot;type&quot;: &quot;accept&quot;,
        &quot;agentName&quot;: &quot;agent3&quot;
        }
        ],
        &quot;allAttempts&quot;: [
        // 長いので省略
        ]
        }
        </code></pre>
        <p><code>&quot;isAgreed&quot;: true</code> かつ <code>&quot;attemptsCount&quot;: 8</code> なので 8
        回目の試行で同意できたことがわかる。 このとき、主食は Rice メインディッシュは
        Chicken で同意したようだ。</p>
        <h2>まとめ</h2>
        <p>まだ細かい不具合や機能追加などを行っている途中なのだが、一応動くものができてきた。
        こういう bot がやり取りするようなシステムは初めて作ったので面白かった。</p>
        <p>「Agent がメッセージを送り合う」という特性上、それって channel
        があれば楽そうだなぁと思った結果、調べたところ Node.js には Channel
        機能が組み込まれていた。</p>
        <p><a href="https://nodejs.org/api/diagnostics_channel.html">Node.js v21.6.0 - Diagnostics Channel</a></p>
        <p>便利になったものだ。go 言語の goroutines とか clojure の core.async
        みたいなことが簡易的とはいえ Node.js でできるのはありがたい。</p>
        ]]>
      </content:encoded>
      <pubDate>Sun, 21 Jan 2024 00:00:00 GMT</pubDate>
    </item>
    <item>
      <title>React関係で思うことなど</title>
      <link>https://www.kbaba1001.com/posts/2024011602_react/</link>
      <guid isPermaLink="false">https://www.kbaba1001.com/posts/2024011602_react/</guid>
      <description/>
      <content:encoded>
        <![CDATA[<p>React 18.2.0 以降くらいから Next.js にあるような Server 向けの機能などが色々入るようで、
        僕としてはなんかもうちょっと気楽に SPA 作れる UI ライブラリであれば十分なんだけどなぁ、という微妙な気持ち。</p>
        <p>Next.js も触ってるけど面倒くさくて仕方がない。 Server Side Rendering ってそんなにいいものかなぁ。</p>
        <p>最近入った機能だと Suspense は便利だと思ったけど、 server actions とか use server とかちょっと面倒くさいな。</p>
        <p>まぁ、でも React の内部にデータベースへのアクセスなどのサーバーとしての機能も全部もたせたら便利なのかなぁ。
        それってただのモノリスで、また時代が逆行する気がするけど。。。</p>
        <p>じゃあ、 React 以外のライブラリはどうなんだろうか？</p>
        <p>Preact は少し試したことがあるけど次のような感想。</p>
        <ul>
        <li>Signal は便利 (React で jotai や Recoil など使えば大差ないけど)</li>
        <li>色々と React よりきれいな感じはする</li>
        <li>React ライブラリはダックタイピングで動かすので TypeScript との相性は悪い</li>
        <li>preact-cli は webpack なので微妙だった</li>
        <li>結局 React でよくね？感はすごくある</li>
        </ul>
        <p>もう一つやりたいのは Svelte かなぁ。いまいち流行りきってない感じがあるけど、多分好みではあると思う。</p>
        <p>Solid.js も結局 React でよくね？感を払拭できない。あんま流行ってない気もするし。</p>
        <p>htmx もあんま自分好みじゃないしなぁ</p>
        <p><img src="https://www.kbaba1001.com/img/posts/2024011602/google-trend.png" alt="google trend"></p>
        <p>google trend も見てみたけど、React が圧倒的で次いで Vue, Svelte という感じ。
        やや意外なことに Solid.js は htmx よりも人気がない。</p>
        ]]>
      </content:encoded>
      <pubDate>Tue, 16 Jan 2024 00:00:00 GMT</pubDate>
    </item>
    <item>
      <title>妻に C 言語を教えることになった</title>
      <link>https://www.kbaba1001.com/posts/2024011601_teach-c-language-to-my-wife/</link>
      <guid isPermaLink="false">https://www.kbaba1001.com/posts/2024011601_teach-c-language-to-my-wife/</guid>
      <description/>
      <content:encoded>
        <![CDATA[<p>紆余曲折あって妻に C 言語を教えることになった。
        もともとの妻の希望としては、</p>
        <ul>
        <li>データサイエンティストになりたいからデータ分析とか統計学とか学びたい</li>
        <li>ついでにアルゴリズムとかも知りたい</li>
        </ul>
        <p>ということだったので、 Python / Excel / SQL あたりを教えてみたのだが、
        よく話してみるともうちょっと硬派なことをやりたそうだったので、
        いっそのこと C 言語とか TCP/IP とか Linux とかいわゆる情報系の大学でやるようなことを
        ひととおりやらせてみることにした。</p>
        <p>妻からカリキュラムを作って欲しいと言われたので google classroom で一通り作成することにした。</p>
        <p><img src="https://www.kbaba1001.com/img/posts/2024011601/google-classroom.png" alt="google classroom"></p>
        <p>なるべくネット上の無料で使える教材を使いたかったのだが、書籍のほうがわかりやすいということで何冊か買うことになった。</p>
        <ul>
        <li><a href="https://www.amazon.co.jp/dp/4295011088">統計学の基礎から学ぶ Excel データ分析の全知識</a></li>
        <li><a href="https://amzn.asia/d/7rvthWq">入門 統計学(第 2 版): 検定から多変量解析・実験計画法・ベイズ統計学まで</a></li>
        <li><a href="https://amzn.asia/d/6jZ5Xlx">新・明解 C 言語 入門編 第 2 版</a></li>
        <li><a href="https://amzn.asia/d/eLdiWbB">スッキリわかる Python 入門 第 2 版</a></li>
        <li><a href="https://amzn.asia/d/03PX0mL">現場ですぐに使える！ 最新 Python プログラミング逆引き大全 450 の極意</a></li>
        </ul>
        <p>アルゴリズムやデータ構造を勉強するなら結局 C 言語が一番いいのかもしれない。
        Python のような動的型付け言語では型の概念が理解しづらいし、メモリも意識できない。
        アルゴリズムの説明もなんだかんだ言って C++ とかで説明しているのが多いし。</p>
        <p>ついでに Debian の CUI のみインストールさせて、そこから GUI 環境を構築するという課題をやらせるつもり。
        gentoo や Arch Linux ほど難しくはないしちょうどいい課題だと思うのだが、なぜかこれについてまとめているドキュメントがないんだよなぁ。。。
        自分で書きたいと思いつつなかなか進められていないのでこの機会に作ってしまおうかな。</p>
        <p>まだ買ってないけど良さそうだと思っている本:</p>
        <ul>
        <li><a href="https://amzn.asia/d/0vZBXR9">新・明解 C 言語で学ぶアルゴリズムとデータ構造第 2 版</a></li>
        <li><a href="https://amzn.asia/d/ixP2wm4">基礎から学ぶ React/React Hooks</a></li>
        <li><a href="https://amzn.asia/d/4LU5Ial">体験しながら学ぶ ネットワーク技術入門</a></li>
        <li><a href="https://amzn.asia/d/2IqlFSx">ネットワーク 入門・構築の教科書</a></li>
        <li><a href="https://amzn.asia/d/iWxHu0w">ヤマハルーター＆スイッチによるネットワーク構築 標準教科書</a></li>
        <li>Linux 関係の入門書で何かしらおすすめがほしい (日経 Linux 読む方がいいかなぁ)
        <ul>
        <li><a href="https://amzn.asia/d/aDKwDma">日経 Linux 2023 年 7 月号</a></li>
        </ul>
        </li>
        </ul>
        <p>ここまで来ると Docker とか git とかも知っておいてほしい気もする。
        硬派にやるなら『コンピュータの構成と設計』とかもやっていい気もする。
        応用編として、画像処理、音声処理、AI とかかなぁ。</p>
        ]]>
      </content:encoded>
      <pubDate>Tue, 16 Jan 2024 00:00:00 GMT</pubDate>
    </item>
    <item>
      <title>gRPC, tRPC, GraphQL, REST について</title>
      <link>https://www.kbaba1001.com/posts/2024010501_grpc-trpc-graphql/</link>
      <guid isPermaLink="false">https://www.kbaba1001.com/posts/2024010501_grpc-trpc-graphql/</guid>
      <description>APIのプロトコルについて思うことなど</description>
      <content:encoded>
        <![CDATA[<p>API のプロトコルを色々触ったので雑感まとめ。</p>
        <h2>REST</h2>
        <ul>
        <li><a href="https://developer.mozilla.org/en-US/docs/Glossary/REST">REST - MDN</a></li>
        </ul>
        <p>おそらく現在一番広く使われてる方式が REST だと思う。今更特に言うことはないので省略</p>
        <h2>GraphQL</h2>
        <ul>
        <li><a href="https://graphql.org/">GraphQL</a></li>
        </ul>
        <p>schema 作って各言語で実装を自動生成する。
        最大の特徴はほしい情報をクライアント側からある程度指定できること。
        汎用性が必要で一般公開するような API なら REST より良い気がする。</p>
        <h2>gRPC</h2>
        <ul>
        <li><a href="https://grpc.io/">gRPC</a></li>
        </ul>
        <p>GraphQL のようにクライアント側からの指定はできないものの、 schema (proto ファイル) でサーバーとクライアントの
        やり取りするデータ、API のインタフェースなど一通りのことを定義しておくことができるので、
        ある程度やり取りの内容が決まっている場合には REST よりはかっちり作れるし GraphQL ほど手間でもない。
        わりといいとこ取りをしている気がする。</p>
        <p>こういう必要な schema 定義してよしなにやろうみたいなの昔から色々あるけど、なんかいまいち流行り切らない印象。</p>
        <p>問題は gRPC の proto ファイルから各言語の実装を自動生成するライブラリのクオリティにばらつきがあること。
        これは GraphQL でも言えることだけど、どうしても自動生成系はここがネックになりがち。
        私みたいにマイナー言語使わなければ大して問題にはならないけども……。</p>
        <h2>tRPC</h2>
        <ul>
        <li><a href="https://trpc.io/">tRPC</a></li>
        </ul>
        <p>サーバー、クライアント共に TypeScript なのであれば tRPC が一番楽だと思う。
        TypeScript でインタフェースを定義してそれをサーバー、クライアントで共有する。
        TypeScript に絞っている分、 GraphQL や gRPC のように schema を定義せずにインタフェースをやり取りできるが、
        他の言語への汎用性はない。</p>
        <p>不安要素としては、開発元が Vercel なので最近の Next.js の動きを見ていると tRPC のような仕組みよりは Server Action 推しだと思うので、
        今後メンテがされていくのかどうか疑問だ。
        実際 tRPC が盛り上がった 2 年くらい前からあまり進歩がなさそう。</p>
        <p>良いものだと思うけど採用するかどうかちょっと悩むなぁ……。
        サーバー、クライアント共に TypeScript で、通信周りを楽したいなら割りとありな気がするけど。</p>
        ]]>
      </content:encoded>
      <pubDate>Fri, 05 Jan 2024 00:00:00 GMT</pubDate>
    </item>
  </channel>
</rss>