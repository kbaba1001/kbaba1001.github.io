<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:wfw="http://wellformedweb.org/CommentAPI/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:sy="http://purl.org/rss/1.0/modules/syndication/" xmlns:slash="http://purl.org/rss/1.0/modules/slash/" version="2.0">
  <channel>
    <title>kbaba1001 ブログ</title>
    <link>https://www.kbaba1001.com/</link>
    <atom:link href="https://www.kbaba1001.com/feed.rss" rel="self" type="application/rss+xml"/>
    <description>Clojure 好きなプログラマ kbaba1001 のブログ</description>
    <lastBuildDate>Sun, 17 Dec 2023 15:00:00 GMT</lastBuildDate>
    <language>ja_JP</language>
    <generator>Lume v2.0.1</generator>
    <item>
      <title>Deno で Google Meet みたいなやつを作ってみようと思っている</title>
      <link>https://www.kbaba1001.com/posts/2024020601_deno/</link>
      <guid isPermaLink="false">https://www.kbaba1001.com/posts/2024020601_deno/</guid>
      <description/>
      <content:encoded>
        <![CDATA[<p>Google Meet みたいなブラウザで動作するビデオ会議ツールを作りたい。</p>
        <p>そこで Node で作っても良いのだが、 以前から少しずつ使っている Deno
        をそろそろ本格的に使っていきたいので試しにサーバー、フロント共に Deno
        でやってみることにした。</p>
        <p>ある程度動くものができたらオープンソースにする予定。</p>
        <h2>Deno の API サーバー事情</h2>
        <p>Deno には <code>Deno.serve</code> というシンプルなサーバーが組み込まれている。</p>
        <ul>
        <li><a href="https://docs.deno.com/runtime/tutorials/http_server">Simple HTTP Web Server</a></li>
        </ul>
        <p>しかしこれは Routing の機能などがないので、そこは別途何とかするしかない。</p>
        <p>色々調べたのだが、現状、それなりにメンテされてそうで使われてそうなライブラリは次</p>
        <ul>
        <li><a href="https://oakserver.github.io/oak/">oak</a></li>
        <li><a href="https://hono.dev/">Hono</a></li>
        </ul>
        <p>他にも色々あったけど、2年くらい前にコミットが止まっているものが多くてやめた。</p>
        <p>Deno
        は少し使ってみればわかるけど、本体にまだまだ変更が入るのでライブラリを作ってもメンテするのが大変なのよね。。。
        そのため放置されがちなのは理解できる。</p>
        <p>今回は Hono
        を採用することにした。以前から少しブログなどで注目されているのを知っていたし、日本人が作っているので応援したいため。</p>
        <h2>Deno で React のフロントエンドを作る</h2>
        <p>どうせならフロントエンドも Deno で開発したい。 npm が使えるようになったので Vite
        も使えるようだが、次のライブラリを入れたほうが便利そうだったので採用した。</p>
        <ul>
        <li><a href="https://github.com/anatoo/vite-deno-plugin">vite-deno-plugin</a></li>
        </ul>
        <p><a href="https://github.com/anatoo/vite-deno-plugin/tree/main/examples/react">React Example</a>
        が用意されているのでこれをコピーして土台とした。</p>
        <h3>その他、採用予定のライブラリ</h3>
        <ul>
        <li><a href="https://github.com/molefrog/wouter">wouter</a></li>
        <li><a href="https://www.kuma-ui.com/">Kuma UI</a></li>
        <li><a href="https://jotai.org/">jotai</a></li>
        <li><a href="https://github.com/jotaijs/jotai-tanstack-query">jotai-tanstack-query</a></li>
        <li><a href="https://github.com/jotaijs/jotai-uncontrolled">jotai-uncontrolled</a>
        <ul>
        <li><a href="https://zenn.dev/dai_shi/articles/01813b22907dcf">Document</a></li>
        </ul>
        </li>
        </ul>
        <p>この辺を使う予定。</p>
        <p>wouter は Preact 対応してあるということで Deno
        界隈ではちょっと使われ始めているライブラリのようだ。 不十分だったら React Router
        に変えようと思う。</p>
        <p>Kuma UI は Chakra UI からの置き換えを考えている。 Kuma UI は Chakra UI
        ほど機能がないのだが、 CSS の読み込みの仕組みを改善していて速いとのこと。</p>
        <p>jotai
        は以前から使っているのだが、もっと本格的に使っていきたいのでプラグインも入れる予定。</p>
        <h2>他の Web フレームワーク</h2>
        <ul>
        <li><a href="https://fresh.deno.dev/">Fresh</a>
        <ul>
        <li>Deno の公式(たぶん) の Web Framework</li>
        <li>サーバー、フロント共に作れるが次の理由で今回は不採用
        <ul>
        <li>Streaming 対応が不安なため</li>
        <li>サーバーとフロントを分離した設計にしたいため</li>
        </ul>
        </li>
        </ul>
        </li>
        <li><a href="https://github.com/exhibitionist-digital/ultra">Ultra</a>
        <ul>
        <li>Fresh に似ているけど React が使える</li>
        </ul>
        </li>
        </ul>
        <h2>Streaming Data とデータベース</h2>
        <p>ビデオ会議ツールを作るために
        <a href="https://developer.mozilla.org/en-US/docs/Web/API/Streams_API">Web Streams API</a>
        を使って Streaming データをサーバーとフロントでやり取りする設計を考えている。</p>
        <p>そこで、 Streaming
        データをどのようにデータベースに保存するかが重要になってくる。 普通の RDBMS
        でも良いのだが、以前からちょっと気になっている
        <a href="https://www.timescale.com/">Timescale DB</a> を使ってみようと思っている。 これは
        PostgreSQL を拡張したデータベースなので使いやすそうだなと思っている。</p>
        <p>Docker でもクラウドでも使える。</p>
        <h2>全文検索</h2>
        <p>また、今どき全文検索も必須の機能となってきたのだが、
        日本語対応も含めて考えるとデフォルトの PostgreSQL では心もとない。</p>
        <p>単に Google Meet クローンを作るだけなら全文検索はいらない気もするけど、
        なんとなくチャット機能も作りたいので、実際には Discord
        クローンみたいになりそうだ。</p>
        <p>で、次のような候補を考えた。</p>
        <ul>
        <li><a href="https://github.com/pgbigm/pg_bigm">pg_bigm</a>
        <ul>
        <li>PostgreSQL のプラグイン。 AWS RDS や GCP Cloud SQL
        でも使えるが、他に比べると遅いらしい。あんま開発もされてなさそう。</li>
        </ul>
        </li>
        <li><a href="https://pgroonga.github.io/">PGroonga</a>
        <ul>
        <li>これも PostgreSQL のプラグイン。速いのだが pg_bigm と違って AWS RDS や GCP
        Cloud SQL がサポートしてない。</li>
        <li>なぜか Supabase
        では使えるのだが、他のクラウドサービスでも使えるように営業を頑張ってほしいところ……。</li>
        </ul>
        </li>
        <li><a href="https://typesense.org/">TypeSense</a>
        <ul>
        <li>これはプラグインではなく ElasticSearch や Algoria
        のような独立した全文検索エンジン</li>
        <li>Docker
        のイメージもありオンプレでも使えるし、クラウドサービスも提供されている</li>
        <li>ドキュメントを読んだ感じ ElasticSearch ほど面倒なクエリではなさそう</li>
        </ul>
        </li>
        </ul>
        <p>総合的に考えて今の第一候補は TypeSense 。</p>
        <h2>SQL Builder, ORM 的なやつ</h2>
        <p><a href="https://kysely.dev/">kysely</a> が deno
        でも動くようなので、特にトラブルなければこれかなぁ。 Timescale DB
        との相性が若干不安ではあるが...。</p>
        <p>kysely そのものは必要十分な機能を備えていてわりと気に入っている。 Prisma
        が苦手な人には特におすすめかも知れない。</p>
        <h2>TypeScript でやるのか？ 一応そのつもり...</h2>
        <p><a href="https://www.kbaba1001.com/posts/2023122001_typescript/">TypeScriptって面倒くさいだけでは...</a>
        で書いた通り TypeScript があまり好きではないのだが、今回は一応 TypeScript
        前提で考えている。</p>
        <p>理由としては</p>
        <ul>
        <li>コード生成機能を使うようなものがない（GraphQL, gRPC, Prisma
        など）はずなので、自分で型を定義する分にはマシではなかろうか</li>
        <li>テスト減らしたい</li>
        <li>Clojure
        でもそうなんだけど関数の引数として何を期待しているかくらいは明示的にしたい事がある
        (とはいえ今更 prop-types はなぁ...)</li>
        <li>Deno なら Repl とか環境セットアップが面倒くさくない</li>
        </ul>
        <p>らへん。</p>
        <p>どうしても生産性落ちそうだったら JS にするかもしれない。</p>
        ]]>
      </content:encoded>
      <pubDate>Tue, 06 Feb 2024 00:00:00 GMT</pubDate>
    </item>
    <item>
      <title>NextCloudで家庭内に閉じたチャットとファイル共有システムを構築した</title>
      <link>https://www.kbaba1001.com/posts/2024020201_nextcloud/</link>
      <guid isPermaLink="false">https://www.kbaba1001.com/posts/2024020201_nextcloud/</guid>
      <description/>
      <content:encoded>
        <![CDATA[<p><a href="https://nextcloud.com/">Nextcloud</a> というオンプレで使えるグループウェアを Conoha
        のサーバーで動かして、家庭内の会話などがクラウドサービスの会社にバレないようになった。</p>
        <p>主に使いたかったのはチャットとファイル共有。</p>
        <h2>チャット</h2>
        <p><img src="https://www.kbaba1001.com/img/posts/2024020201/nextcloud.png" alt="nextcloud"></p>
        <p>チャットの画面。妻との会話が主だがトピックごとに整理する予定。</p>
        <p>さらに Twitter
        という自分だけのルームを作ったのでここで独り言も言うことができる。便利。</p>
        <p>いろいろ試したけど、ちゃんと音声通話も問題なくできた。</p>
        <p>google play や apple store に
        <a href="https://play.google.com/store/apps/details?id=com.nextcloud.talk2">Nextcloud Talk</a>
        というアプリがあり、これを使えばスマホでも快適に会話ができる。</p>
        <h2>ファイル共有</h2>
        <p><img src="https://www.kbaba1001.com/img/posts/2024020201/nextcloud2.png" alt="nextcloud2"></p>
        <p>google drive
        みたいな感じで使える。マークダウンもエディタで表示してくれて便利そう。
        素晴らしい。</p>
        <p><a href="https://play.google.com/store/apps/details?id=com.nextcloud.client">スマホアプリ</a>
        もある。</p>
        <h2>導入手順</h2>
        <p>Nextcloud は導入が非常に簡単だったのが最高だった。</p>
        <p>基本的に
        <a href="https://github.com/nextcloud/all-in-one?tab=readme-ov-file#how-to-use-this">all-in-one</a>
        の手順に従っただけ。</p>
        <ul>
        <li>docker をインストール</li>
        <li>docker で ipv6 を使えるように設定変更</li>
        <li>docker run で nextcloud を動かす</li>
        <li>ufw で Firewall 設定を変更</li>
        <li>ブラウザで https://xxxxx:8080 にアクセスして初期設定</li>
        <li>上記の管理画面 (Nextcloud AIO) は Nextcloud
        をセットアップするための管理画面なので、適当に全文検索の拡張入れたりタイムゾーンを設定したりして
        Nextcloud 本体をインストールした</li>
        <li>その後、 443 ポートで Nextcloud
        が動くのでドメインなど設定して、一般アカウントを追加</li>
        </ul>
        <p>この all-in-one の docker
        が非常に優秀で何もしなくてもセットアップできてしまった。 全部終わると 10
        個くらいのコンテナが動いていた。</p>
        <p>これくらいの手軽さでできるならちょっとした少人数の会社のグループウェアとして使っても良さそう。</p>
        ]]>
      </content:encoded>
      <pubDate>Fri, 02 Feb 2024 00:00:00 GMT</pubDate>
    </item>
    <item>
      <title>サーバー内での docker compose up をローカルから行う方法</title>
      <link>https://www.kbaba1001.com/posts/2024020101_docker-context/</link>
      <guid isPermaLink="false">https://www.kbaba1001.com/posts/2024020101_docker-context/</guid>
      <description/>
      <content:encoded>
        <![CDATA[<p>まずサーバーで docker や docker compose が動くようにしておく。 その後、</p>
        <pre><code class="language-bash">$ DOCKER_HOST=&quot;ssh://user@remotehost&quot; docker compose up -d
        </code></pre>
        <p>するだけで遠隔サーバーで docker container を起動できる。</p>
        <p>知らなかった...。</p>
        <p>さらに docker context を使うと DOCKER_HOST を変えなくても指定した環境で docker
        compose up できる。</p>
        <pre><code class="language-bash">$ docker context create remote --docker &quot;host=ssh://user@remotemachine&quot;
        $ docker --context remote compose up -d
        </code></pre>
        <div class="post-learge-font">
        便利すぎでは～！！
        </div>
        <p>もちろん <code>~/.ssh/config</code> に設定した Host 名も使える。 僕の場合、 <code>~/.ssh/config</code>
        に次のような設定がある。</p>
        <pre><code class="language-bash">host monday
        HostName xxx.xxx.xxx.xxx
        User xxxxxxxx
        ForwardAgent yes
        IdentityFile ~/.ssh/id_ed25519
        </code></pre>
        <p>ので</p>
        <pre><code class="language-bash">$ DOCKER_HOST=&quot;ssh://monday&quot; docker compose up -d
        </code></pre>
        <p>でよい。</p>
        <p>参考:
        <a href="https://www.docker.com/blog/how-to-deploy-on-remote-docker-hosts-with-docker-compose/">How to deploy on remote Docker hosts with docker-compose</a></p>
        <p>本格的に運用するなら k3s とかで k8s 環境を作ったほうが良さそう。</p>
        ]]>
      </content:encoded>
      <pubDate>Thu, 01 Feb 2024 00:00:00 GMT</pubDate>
    </item>
    <item>
      <title>自宅サーバーに github、 dropbox、 ngrok みたいなのがほしい</title>
      <link>https://www.kbaba1001.com/posts/2024013101_on-premises/</link>
      <guid isPermaLink="false">https://www.kbaba1001.com/posts/2024013101_on-premises/</guid>
      <description/>
      <content:encoded>
        <![CDATA[<p>自宅サーバーの活用について考えるとやっぱりファイル共有みたいなことがしたいし、
        どうせなら git サーバーとして push/pull したい。 固定 IP が面倒くさくて ngrok
        を使っているが、そこそこお値段がするのでどうせならここもオープンソースにしたい。</p>
        <p>みたいなことを考えた結果、次を導入しようと思っている。</p>
        <ul>
        <li>ファイル共有: <a href="https://onionshare.org/">OnionShare</a></li>
        <li>git サーバー: <a href="https://github.com/gitbucket/gitbucket">GitBucket</a></li>
        <li>トンネリング: <a href="https://github.com/fatedier/frp">frp</a></li>
        </ul>
        <h3>ファイル共有 (Dropbox alternatives)</h3>
        <p>あまりクラウドに置いておきたくないデータがいくつかあり、そういうのを自宅サーバーに置いておきたいのだが、
        単に SSH するだけだとファイルの閲覧が不便だったりするので、 Dropbox
        的に使えるやつがほしくなった。</p>
        <p><a href="https://min.io/">Minio</a> が GUI ツールもあるのでそれでもいいのだが、調べたら
        <a href="https://onionshare.org/">OnionShare</a>
        というのがスマホアプリもあって良さそうな気がしたので試してみたい。</p>
        <h3>git サーバー (Github alternatives)</h3>
        <p><a href="https://about.gitlab.com/">GitLab</a>
        とかが有名だがそんなに高機能じゃなくていいのと、
        前から少し気になっていることもあり
        <a href="https://github.com/gitbucket/gitbucket">GitBucket</a> を導入予定。
        これは確か日本人が作っていたはず。</p>
        <h3>トンネリング (ngrok alternatives)</h3>
        <p><a href="https://ngrok.com/">ngrok</a> の production apps プランを使っているのだが、１つの
        domain を作るたびに月 $15
        かかるので何個かやっているとそれなりの出費になってきた。</p>
        <p>調べたらめちゃくちゃしっかりしたまとめが作ってあった。
        <a href="https://github.com/anderspitman/awesome-tunneling">awesome-tunneling</a></p>
        <p>これによると、 CloudFlare Tunnel がおすすめ、 self-host したいなら
        <a href="https://github.com/fatedier/frp">frp</a> という感じなのでおすすめに従って、 frp
        を試してみようと思う。</p>
        <h3>雑感</h3>
        <p>自宅サーバーがあると電気代を無駄にしたくないので活用したくなる。</p>
        ]]>
      </content:encoded>
      <pubDate>Wed, 31 Jan 2024 00:00:00 GMT</pubDate>
    </item>
    <item>
      <title>いつの間にか AtCoder で Babashka が動くようになっていた</title>
      <link>https://www.kbaba1001.com/posts/2024012902_babashka-at-coder/</link>
      <guid isPermaLink="false">https://www.kbaba1001.com/posts/2024012902_babashka-at-coder/</guid>
      <description/>
      <content:encoded>
        <![CDATA[<p><img src="https://www.kbaba1001.com/img/posts/2024012902/atcoder.png" alt="AtCoder"></p>
        <div class="post-learge-font">
        <p>いつの間にか <a href="https://atcoder.jp/">AtCoder</a> で
        <a href="https://github.com/babashka/babashka">Babashka</a> が使えるようになっている！！！</p>
        <p>めちゃくちゃ嬉しい！！</p>
        <p>AtCoder 始めます！！</p>
        </div>
        <p>どういうことかというと、今まで AtCoder で普通の Clojure
        の実行はできていたのですが、どうも起動時間も含めて実行速度
        として計算されていたらしく、とんでもなく不利でした。</p>
        <p>一方 Babashka は GraalVM を使った起動がめちゃくちゃ速い Clojure
        の実行環境で、これが AtCoder で使えたらいいのになぁと多くの Clojurians
        は思ってました。</p>
        <div class="post-learge-font">
        <p>で、それが叶いました。</p>
        <p>最高ー！！</p>
        </div>
        ]]>
      </content:encoded>
      <pubDate>Mon, 29 Jan 2024 00:00:00 GMT</pubDate>
    </item>
    <item>
      <title>2 月 25 日 (日) に「１か月間全力で個人サイトを作ろうハッカソン、発表会」を開催します</title>
      <link>https://www.kbaba1001.com/posts/2024012901_hackathon/</link>
      <guid isPermaLink="false">https://www.kbaba1001.com/posts/2024012901_hackathon/</guid>
      <description/>
      <content:encoded>
        <![CDATA[<p><img src="https://www.kbaba1001.com/img/posts/2024012901_hackathon.jpg" alt="2024012901_hackathon.jpg"></p>
        <p>個人サイトを<strong>全力で</strong>作りましょう！</p>
        <p><strong>全力</strong>とは自分の持てる技術の全てを費やすという意味です。</p>
        <p>いにしえの個人サイトといえば、</p>
        <ul>
        <li>アクセスカウンター</li>
        <li>Web 拍手</li>
        <li>掲示板</li>
        <li>チャット</li>
        <li>相互リンク</li>
        </ul>
        <p>など当時の技術（だいたい CGI）をフル動員した個人サイトがたくさんあったものです。
        徐々に Twitter などの SNS に移り変わっていきましたが、それまでは皆 HTML とか CSS
        とか 自力で勉強して個人サイトを作ってました。
        今にして思えばすごい時代です。プログラマでもない人たちがこれら技術を自力でなんとか勉強して
        いたわけですから。</p>
        <p>さて、そんな中なぜ今更個人サイトを作るのかというと、個人的に 昨今 Twitter が X
        になったりしてなんとなく SNS やクラウドサービスに
        疑問を持つような機会が増えてきました。
        結局信用できるのは自分で運用しているものだけかなぁ、みたいな気持ちがあります。</p>
        <p>現在このブログは静的サイトジェネレータを使って Github Pages で公開していますが、
        もっと掲示板などの機能を作ってみたくなってきました。</p>
        <p>一人で作っても良いのですが、誰か一緒にやりたい方がいたら嬉しいのでハッカソンにすることにしました。</p>
        <h2>ハッカソンの概要</h2>
        <p>今からだいたい１ヶ月後の 2 月 25 日 (日) に
        「<a href="https://connpass.com/event/309089/">１か月間全力で個人サイトを作ろうハッカソン、発表会</a>」
        を開催します。</p>
        <p>このときに、各参加者に自分で作った個人サイトを発表していただきます。</p>
        <p>なので、 2 月 25 日 (日)までに各自、全力で個人サイトを作ってください。</p>
        <h3>参加方法</h3>
        <ul>
        <li>「<a href="https://connpass.com/event/309089/">１か月間全力で個人サイトを作ろうハッカソン、発表会</a>」に申し込んでください。</li>
        <li>参加費等はありません。</li>
        <li>いつでも参加表明して頂いて大丈夫です（例えば発表会の前日から数時間で作った、でも OK です）</li>
        </ul>
        <h3>発表会当日</h3>
        <ul>
        <li>オンライン (google meet) で開催します。(URL は connpass
        の参加者にのみ公開します)</li>
        <li>顔出しは任意です。</li>
        <li>作品を参加者自身でプレゼンして頂きます。
        <ul>
        <li>発表時間は参加人数にもよりますが 15 分程度を想定</li>
        </ul>
        </li>
        <li>主催者の独断で審査を行い、優勝者を決めます。</li>
        </ul>
        <h3>作品の条件</h3>
        <ul>
        <li><strong>インターネット上に公開されており、 URL (または IP アドレス)
        でアクセスできることを必須とします。</strong></li>
        <li>個人サイトのコンテツ内容は自由です。 R-18
        を含む場合はそのページを開く前に年齢確認をするなど配慮をお願いします。
        <ul>
        <li>発表会では全年齢向けのページのみ表示し、審査の対象とします</li>
        </ul>
        </li>
        </ul>
        <h3>審査について</h3>
        <ul>
        <li>発表会の最後に、各参加者の発表会の内容を元にして主催者の独断で優勝者を決めます</li>
        <li>評価基準として技術点、個人サイトらしさ、コンテンツの面白さ、将来性などを考慮します</li>
        <li>優勝者には景品として ◯◯◯◯ を差し上げます (TODO 景品決める)</li>
        </ul>
        ]]>
      </content:encoded>
      <pubDate>Mon, 29 Jan 2024 00:00:00 GMT</pubDate>
    </item>
    <item>
      <title>いにしえのホームページを Clojure の最先端技術で作りたい</title>
      <link>https://www.kbaba1001.com/posts/2024012501_homepage/</link>
      <guid isPermaLink="false">https://www.kbaba1001.com/posts/2024012501_homepage/</guid>
      <description/>
      <content:encoded>
        <![CDATA[<p>このブログを運用し始めて約１か月。</p>
        <p>さっそくアクセスカウンターとか掲示板とか欲しくなってきた。 Twitter
        もやめてしまったのでどうせならマイクロポストの機能もほしい。</p>
        <p>そんな感じの個人サイトを Clojure で作ろうかと思っている。</p>
        <h3>サーバーサイド開発について</h3>
        <p>サーバーサイドを今まで <a href="https://github.com/duct-framework/duct">Duct</a>
        で作ってきたのだが、別に Duct 使わなくてもいいんじゃないかなと思えてきた。 Duct
        は <code>defmethod</code> を活用して関数を疎結合にしてシステムを構築するのだが、</p>
        <ul>
        <li>別に毎回そこまで疎結合じゃなくてもいい</li>
        <li>むしろコードジャンプできなくて辛い</li>
        <li>edn ファイルでシステムを定義するのが面倒くさい</li>
        </ul>
        <p>というあたりでやめようと思った。</p>
        <p>ではどうするかというと、他の言語でよくやるのと同じようにオートリロードできれば十分だと思う。
        調べたら
        <a href="https://ring-clojure.github.io/ring/ring.middleware.reload.html">ring にはそもそもオートリロードの機能がある</a>
        ようなのでこれを使いたい。
        <a href="https://github.com/weavejester/ring-refresh">ring-refresh</a>
        というライブラリもあるし。
        <a href="https://practical.li/clojure-web-services/projects/leiningen/todo-app/reloading-the-application/">使い方</a></p>
        <p>あとは <a href="https://github.com/metosin/reitit">reitit</a>
        とかでルーティングを作れば十分だろう。 DB
        コネクションの各ファイルへの受け渡しだけなんとかする。 必要であればここだけ
        <a href="https://github.com/clojure/core.async">core.async</a> の
        <a href="https://clojuredocs.org/clojure.core.async/pipeline">pipeline</a>
        とかで疎結合にしておけばいい。</p>
        <p>参考:
        <a href="https://boxofpapers.hatenablog.com/entry/core_async">Clojure + core.async による非同期＆並列プロセスの世界</a></p>
        <h3>フロントエンド開発について</h3>
        <p>今まで <a href="https://github.com/thheller/shadow-cljs">shadow-cljs</a> +
        <a href="https://github.com/lilactown/helix">helix</a>
        構成を試してきてこれはかなり快適だったのだが、新しい試みとして
        <a href="https://github.com/squint-cljs/squint">Squint</a> を試したいと思っている。</p>
        <p>Squint は ClojureScript を js に変換するコンパイラで、最大の特徴として <strong>Java
        に依存していない!!</strong>。 つまり TypeScript のコンパイラなどと同様に package.json
        に書いておけば、それだけで cljs を js に変換できる。 shadow-cljs
        がやりたかったことをもう一歩進めた感じだ。 Squint は js
        に寄っているが、もっと標準的な ClojureScript に寄せた
        <a href="https://github.com/squint-cljs/cherry">Cherry</a> というのもある。 Squint を使えば
        React や Vite などのフロントエンド開発で使われるツールを
        そのまま使うことができる。<a href="https://github.com/squint-cljs/squint/tree/main/examples/vite-react">examples/vite-react</a></p>
        <p>これらは <a href="https://github.com/babashka/babashka">babashka</a> の作成者として有名な
        borkdude
        さんの作品で、彼は本当にこういうものを作るのが上手だしまめに作っていると思う。
        尊敬しかない。</p>
        <p>Squint
        はまだ本番環境で使うことを推奨していないようだけど、まぁ個人サイトのフロントエンドを作るくらいなら後で
        Squint の仕様が変わったとしてもあまり困らない気がする。 Clojure コミュニティの
        Slack 見ているとすでに結構出来上がっている雰囲気あるし。</p>
        <p>Squint は CljureScript の歴史を変える可能性があるプロダクトだと思っているので
        ぜひとも試してみたい。 今までの ClojureScript では面倒になる <code>Promise</code>,
        <code>async/await</code> まわりも楽にかけそうだし、 <code>jsx</code> との統合も魅力的だ。 一方で nREPL
        や Macros も使える。</p>
        <p>最高では～！</p>
        ]]>
      </content:encoded>
      <pubDate>Thu, 25 Jan 2024 00:00:00 GMT</pubDate>
    </item>
    <item>
      <title>久々に買ってみた技術書</title>
      <link>https://www.kbaba1001.com/posts/2024012201_technologies-books/</link>
      <guid isPermaLink="false">https://www.kbaba1001.com/posts/2024012201_technologies-books/</guid>
      <description/>
      <content:encoded>
        <![CDATA[<p>久しぶりに Web 系の技術書を買ってみた。</p>
        <p><img src="https://www.kbaba1001.com/img/posts/2024012201/tech-books.jpg" alt="tech-books"></p>
        <ul>
        <li>Rust と WebAssembly によるゲーム開発</li>
        <li>Web パフォーマンスチューニング ISUCON</li>
        <li>フロントエンド開発のためのセキュリティ入門</li>
        <li>フロントエンド開発のためのテスト入門</li>
        </ul>
        <p>長らく技術書を買ったり読んだりしてなかった。だいたいのことはライブラリとかの公式サイト読む方がいいし。
        最近少し大き目の本屋に行く機会があって、久しぶりに技術書を見ていたら色々と良さそうな本もあったので、
        久しぶりに自分のために買ってみることにした。</p>
        <p>『フロントエンド開発のためのテスト入門』と『フロントエンド開発のためのセキュリティ入門』の２冊は前から気になっていたので購入。
        そういえばあまりフロントのテスト書いてなかったわ。 js-dom とか一応入れるだけ入れてちゃんとした React コンポーネントのテスト書いたことないかも。という自戒も込めて。</p>
        <p>『フロントエンド開発のためのセキュリティ入門』の方は答え合わせのつもりで購入。たぶんだいたい知っているとは思うけど、この際知識を整理しておきたい。</p>
        <p>『Web パフォーマンスチューニング ISUCON』は Amazon で見つけて衝動買い。
        パフォーマンスチューニングも意外と知らないことある気がした。
        CDN とかあんま詳しくないし。</p>
        <p>『Rust と WebAssembly によるゲーム開発』は Rust と WebAssembly の知識が両方 0 なのだが、
        WebAssembly に GC がないので Rust のような GC がなくても現代的な開発ができる言語が人気ときいて
        やってみたくなったため。
        ゲーム開発をする予定はないけど、フロントではちょっと重い処理をなんとか速くしたいみたいなときに
        WebAssembly 使えたら面白いかもなぁ、という気持ち。</p>
        <p>何にせよ自分のために技術の本を買うのは結構久々で、普通に読むのが楽しみだ。
        新人教育的な目的で購入した本は結構あるし、一時期は O'Reilly online で英語の本とか読んでたけど、
        最近はそういうのもすっかりやらなくなってしまった。</p>
        ]]>
      </content:encoded>
      <pubDate>Mon, 22 Jan 2024 00:00:00 GMT</pubDate>
    </item>
    <item>
      <title>自動交渉のライブラリを作った</title>
      <link>https://www.kbaba1001.com/posts/2024012101_auto-negotiator/</link>
      <guid isPermaLink="false">https://www.kbaba1001.com/posts/2024012101_auto-negotiator/</guid>
      <description/>
      <content:encoded>
        <![CDATA[<p><a href="https://github.com/neumann-tokyo/auto_negotiator">Auto Negotiator</a>
        というライブラリを TypeScript で作った。</p>
        <p>npm package はこちら:
        <a href="https://www.npmjs.com/package/auto_negotiator">auto_negotiator</a></p>
        <h2>自動交渉の概要</h2>
        <p>自動交渉については ↓
        の記事などがわかりやすい（というかこれ以外あんまなかった）。</p>
        <p><a href="https://engineering.mercari.com/blog/entry/2017-12-07-103000/">自動交渉 AI から見る&quot;AI 同士がつながる世界&quot;</a></p>
        <p>自動交渉は交渉を行うエージェントを数体作成して、それらのエージェントの希望を考慮しつつ満場一致になる選択肢を導き出すというもの。</p>
        <p>例えば、夕食のメニューを考えるときに、</p>
        <ul>
        <li>主食
        <ul>
        <li>ご飯</li>
        <li>パン</li>
        <li>麺</li>
        </ul>
        </li>
        <li>メインディッシュ
        <ul>
        <li>ステーキ</li>
        <li>魚</li>
        <li>チキン</li>
        </ul>
        </li>
        </ul>
        <p>みたいな選択肢があって、エージェント A は
        <code>{主食: ご飯, メインディッシュ: ステーキ}</code> がよく、エージェント B は
        <code>{主食: ご飯, メインディッシュ: 魚}</code>
        がよいという意見を持っている場合に、エージェント A, B
        がある程度納得して同意（満場一致）できる献立を考えるというもの。</p>
        <h2>プログラムでの表現</h2>
        <p>自動交渉を行うには、エージェントとトピックが必要だ。
        ライブラリの本体とは別にサンプルコードも用意したので、以下はサンプルコードを元にして説明する。</p>
        <h3>トピック</h3>
        <p>まずトピックについて説明する。</p>
        <p><a href="https://github.com/neumann-tokyo/auto_negotiator/blob/main/sample/topic/dinner/agent1.ts">https://github.com/neumann-tokyo/auto_negotiator/blob/main/sample/topic/dinner/agent1.ts</a></p>
        <pre><code class="language-typescript">import { Topic } from &quot;../../../src/types&quot;;
        
        export const topic: Topic = {
        name: &quot;Dinner&quot;,
        description: &quot;What should we have dinner?&quot;,
        discount_factor: 0.1,
        reservation: 0.3,
        issues: [
        {
        name: &quot;Staple food&quot;,
        weight: 0.3,
        items: [
        {
        name: &quot;Rice&quot;,
        evaluation: 7,
        },
        {
        name: &quot;Noodles&quot;,
        evaluation: 2,
        },
        {
        name: &quot;Bread&quot;,
        evaluation: 1,
        },
        ],
        },
        {
        name: &quot;Main dish&quot;,
        weight: 0.7,
        items: [
        {
        name: &quot;Steak&quot;,
        evaluation: 1,
        },
        {
        name: &quot;Fish&quot;,
        evaluation: 1,
        },
        {
        name: &quot;Chicken&quot;,
        evaluation: 8,
        },
        ],
        },
        ],
        };
        </code></pre>
        <p>上記のように夕食の献立というトピックにたいして、どのような意見を持っているかを決める。
        まず、この agent1 は主食 (Staple food) とメインディッシュ (Main dish)
        に対して、それぞれ 0.3 と 0.7 の重み (weight) をつけている。 weight
        は全体で合計が 1.0 になるように設定する必要があり、どの issue
        に大して優先したいかを示す。 ようするに、 agent1 はメインディッシュに関して 70%
        優先したいと考えている。逆に言えば主食に関しては譲歩しやすい。</p>
        <pre><code>  name: &quot;Staple food&quot;,
        weight: 0.3,
        
        name: &quot;Main dish&quot;,
        weight: 0.7,
        </code></pre>
        <p>次に、issue の中について見てみると <code>items</code> に選択肢として Rice, Noodles, Bread
        があり、その evaluation が 7, 2, 1 となっている。 evaluation については Integer
        でどのような数値を置いても良いが、合計が 10 や 100
        になるようにするとわかりやすい。
        （内部で処理する際はこの数値に重みを付けて正規化する）</p>
        <pre><code class="language-typescript">{
        name: &quot;Staple food&quot;,
        weight: 0.3,
        items: [
        {
        name: &quot;Rice&quot;,
        evaluation: 7,
        },
        {
        name: &quot;Noodles&quot;,
        evaluation: 2,
        },
        {
        name: &quot;Bread&quot;,
        evaluation: 1,
        },
        ],
        },
        </code></pre>
        <p>evaluation
        の値が大きいほどその選択肢にしたいという意思が強くなるため、上記の場合では
        agent1 は Rice を食べたいという意思が強いことがわかる。</p>
        <h3>エージェント</h3>
        <p>エージェントは他のエージェントからの提案やトピックを元にしてどのように自分の意見を主張していくかを決定づけるものだ。</p>
        <p>ソースコードを元に説明する。</p>
        <p><a href="https://github.com/neumann-tokyo/auto_negotiator/blob/main/sample/agents/sample-agent.ts">https://github.com/neumann-tokyo/auto_negotiator/blob/main/sample/agents/sample-agent.ts</a></p>
        <pre><code class="language-typescript">import * as helper from &quot;../../src/helper&quot;;
        import * as types from &quot;../../src/types&quot;;
        
        // この関数は試行のたびに呼び出される。
        // 引数には全体の状況や自分のトピックがはいってきて、自分の意見を返すとそれが他のエージェントにも伝わる。
        export function sampleAgent({
        data: { id, attempts, attemptsCount },
        normalizedTopic,
        }: types.ActionFnParams): types.ActionFnResponse {
        // 現在の試行における他のエージェントからの提案などがはいっている
        const currentAttempt = helper.currentAttempt({ id, attempts });
        
        // 試行回数を元にして譲歩値を設定する。 1.0 - progress なので徐々に譲歩値は下がっていく。
        // つまり、他からの意見に同意しやすくなる
        const progress = helper.progress({ id, attemptsCount });
        const concessionValue = 1.0 - progress;
        
        for (const status of currentAttempt) {
        if (status.type === types.AtemptType.Offer) {
        const anotherConcessionValue = helper.choicesToConcessionValue({
        choices: status.choices,
        });
        
        // 相手からの提案のほうが自分の譲歩値より高いのであれば同意する
        if (concessionValue &lt; anotherConcessionValue) {
        return {
        id,
        choices: status.choices,
        concessionValue: anotherConcessionValue,
        type: types.AtemptType.Accept,
        };
        }
        }
        }
        
        // 同意できない場合に自分の意見を作成する
        const { choices, threshold } = helper.concessionValueToChoices({
        normalizedTopic,
        concessionValue,
        });
        return {
        id,
        choices,
        concessionValue,
        type: types.AtemptType.Offer,
        };
        }
        </code></pre>
        <p>上記はエージェントのサンプルでしかなく、もっと自由に作って良い。</p>
        <h3>自動交渉の実行</h3>
        <p>最後はエージェントとトピックを元にして自動交渉を行う。</p>
        <p><a href="https://github.com/neumann-tokyo/auto_negotiator/blob/main/sample/run.ts">https://github.com/neumann-tokyo/auto_negotiator/blob/main/sample/run.ts</a></p>
        <pre><code class="language-typescript">import { prettyPrint } from &quot;../src/helper&quot;;
        import * as negotiator from &quot;../src/index&quot;;
        import { sampleAgent } from &quot;./agents/sample-agent&quot;;
        import { topic as agent1Topic } from &quot;./topic/dinner/agent1&quot;;
        import { topic as agent2Topic } from &quot;./topic/dinner/agent2&quot;;
        import { topic as agent3Topic } from &quot;./topic/dinner/agent3&quot;;
        
        // これは任意の値を設定して良い
        const channelName = &quot;dinner&quot;;
        
        // エージェントとそのトピックを登録する
        negotiator.defineAgent({
        channelName: channelName,
        agentName: &quot;agent1&quot;,
        topic: agent1Topic,
        actionFn: sampleAgent,
        });
        negotiator.defineAgent({
        channelName: channelName,
        agentName: &quot;agent2&quot;,
        topic: agent2Topic,
        actionFn: sampleAgent,
        });
        negotiator.defineAgent({
        channelName: channelName,
        agentName: &quot;agent3&quot;,
        topic: agent3Topic,
        actionFn: sampleAgent,
        });
        
        // 自動交渉を行う。試行回数（attemptsCount）は 30 回、エージェント数 (agentsCount) は 3 体
        const result = negotiator.negotiate({
        channelName,
        attemptsCount: 30,
        agentsCount: 3,
        });
        
        // 結果の表示
        prettyPrint(result);
        </code></pre>
        <p>自動交渉の結果は次のようになる。</p>
        <p><a href="https://github.com/neumann-tokyo/auto_negotiator/blob/main/sample/result.json">https://github.com/neumann-tokyo/auto_negotiator/blob/main/sample/result.json</a></p>
        <pre><code class="language-json">{
        &quot;isAgreed&quot;: true,
        &quot;id&quot;: 7,
        &quot;attemptsCount&quot;: 8,
        &quot;conclusion&quot;: [
        {
        &quot;choices&quot;: [
        {
        &quot;issueName&quot;: &quot;Staple food&quot;,
        &quot;item&quot;: {
        &quot;name&quot;: &quot;Rice&quot;,
        &quot;evaluation&quot;: 7,
        &quot;normalizedEvaluation&quot;: 0.21000000000000002
        }
        },
        {
        &quot;issueName&quot;: &quot;Main dish&quot;,
        &quot;item&quot;: {
        &quot;name&quot;: &quot;Chicken&quot;,
        &quot;evaluation&quot;: 8,
        &quot;normalizedEvaluation&quot;: 0.5599999999999999
        }
        }
        ],
        &quot;concessionValue&quot;: 0.7666666666666666,
        &quot;type&quot;: &quot;offer&quot;,
        &quot;agentName&quot;: &quot;agent1&quot;
        },
        {
        &quot;choices&quot;: [
        {
        &quot;issueName&quot;: &quot;Staple food&quot;,
        &quot;item&quot;: {
        &quot;name&quot;: &quot;Rice&quot;,
        &quot;evaluation&quot;: 7,
        &quot;normalizedEvaluation&quot;: 0.21000000000000002
        }
        },
        {
        &quot;issueName&quot;: &quot;Main dish&quot;,
        &quot;item&quot;: {
        &quot;name&quot;: &quot;Chicken&quot;,
        &quot;evaluation&quot;: 8,
        &quot;normalizedEvaluation&quot;: 0.5599999999999999
        }
        }
        ],
        &quot;concessionValue&quot;: 0.77,
        &quot;type&quot;: &quot;accept&quot;,
        &quot;agentName&quot;: &quot;agent2&quot;
        },
        {
        &quot;choices&quot;: [
        {
        &quot;issueName&quot;: &quot;Staple food&quot;,
        &quot;item&quot;: {
        &quot;name&quot;: &quot;Rice&quot;,
        &quot;evaluation&quot;: 7,
        &quot;normalizedEvaluation&quot;: 0.21000000000000002
        }
        },
        {
        &quot;issueName&quot;: &quot;Main dish&quot;,
        &quot;item&quot;: {
        &quot;name&quot;: &quot;Chicken&quot;,
        &quot;evaluation&quot;: 8,
        &quot;normalizedEvaluation&quot;: 0.5599999999999999
        }
        }
        ],
        &quot;concessionValue&quot;: 0.77,
        &quot;type&quot;: &quot;accept&quot;,
        &quot;agentName&quot;: &quot;agent3&quot;
        }
        ],
        &quot;allAttempts&quot;: [
        // 長いので省略
        ]
        }
        </code></pre>
        <p><code>&quot;isAgreed&quot;: true</code> かつ <code>&quot;attemptsCount&quot;: 8</code> なので 8
        回目の試行で同意できたことがわかる。 このとき、主食は Rice メインディッシュは
        Chicken で同意したようだ。</p>
        <h2>まとめ</h2>
        <p>まだ細かい不具合や機能追加などを行っている途中なのだが、一応動くものができてきた。
        こういう bot がやり取りするようなシステムは初めて作ったので面白かった。</p>
        <p>「Agent がメッセージを送り合う」という特性上、それって channel
        があれば楽そうだなぁと思った結果、調べたところ Node.js には Channel
        機能が組み込まれていた。</p>
        <p><a href="https://nodejs.org/api/diagnostics_channel.html">Node.js v21.6.0 - Diagnostics Channel</a></p>
        <p>便利になったものだ。go 言語の goroutines とか clojure の core.async
        みたいなことが簡易的とはいえ Node.js でできるのはありがたい。</p>
        ]]>
      </content:encoded>
      <pubDate>Sun, 21 Jan 2024 00:00:00 GMT</pubDate>
    </item>
    <item>
      <title>React関係で思うことなど</title>
      <link>https://www.kbaba1001.com/posts/2024011602_react/</link>
      <guid isPermaLink="false">https://www.kbaba1001.com/posts/2024011602_react/</guid>
      <description/>
      <content:encoded>
        <![CDATA[<p>React 18.2.0 以降くらいから Next.js にあるような Server 向けの機能などが色々入るようで、
        僕としてはなんかもうちょっと気楽に SPA 作れる UI ライブラリであれば十分なんだけどなぁ、という微妙な気持ち。</p>
        <p>Next.js も触ってるけど面倒くさくて仕方がない。 Server Side Rendering ってそんなにいいものかなぁ。</p>
        <p>最近入った機能だと Suspense は便利だと思ったけど、 server actions とか use server とかちょっと面倒くさいな。</p>
        <p>まぁ、でも React の内部にデータベースへのアクセスなどのサーバーとしての機能も全部もたせたら便利なのかなぁ。
        それってただのモノリスで、また時代が逆行する気がするけど。。。</p>
        <p>じゃあ、 React 以外のライブラリはどうなんだろうか？</p>
        <p>Preact は少し試したことがあるけど次のような感想。</p>
        <ul>
        <li>Signal は便利 (React で jotai や Recoil など使えば大差ないけど)</li>
        <li>色々と React よりきれいな感じはする</li>
        <li>React ライブラリはダックタイピングで動かすので TypeScript との相性は悪い</li>
        <li>preact-cli は webpack なので微妙だった</li>
        <li>結局 React でよくね？感はすごくある</li>
        </ul>
        <p>もう一つやりたいのは Svelte かなぁ。いまいち流行りきってない感じがあるけど、多分好みではあると思う。</p>
        <p>Solid.js も結局 React でよくね？感を払拭できない。あんま流行ってない気もするし。</p>
        <p>htmx もあんま自分好みじゃないしなぁ</p>
        <p><img src="https://www.kbaba1001.com/img/posts/2024011602/google-trend.png" alt="google trend"></p>
        <p>google trend も見てみたけど、React が圧倒的で次いで Vue, Svelte という感じ。
        やや意外なことに Solid.js は htmx よりも人気がない。</p>
        ]]>
      </content:encoded>
      <pubDate>Tue, 16 Jan 2024 00:00:00 GMT</pubDate>
    </item>
  </channel>
</rss>